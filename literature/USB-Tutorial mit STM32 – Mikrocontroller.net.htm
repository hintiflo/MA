<!DOCTYPE html>
<html class="client-js" dir="ltr" lang="de"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<title>USB-Tutorial mit STM32 – Mikrocontroller.net</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":!1,"wgSeparatorTransformTable":[",\t.",".\t,"],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","Januar","Februar","März","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"],"wgRequestId":"154e50515dae3afe6cb38ec5","wgCSPNonce":!1,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":!1,"wgNamespaceNumber":0,"wgPageName":"USB-Tutorial_mit_STM32","wgTitle":"USB-Tutorial mit STM32","wgCurRevisionId":104757,"wgRevisionId":104757,"wgArticleId":9686,"wgIsArticle":!0,"wgIsRedirect":!1,"wgAction":"view","wgUserName":"Hintiflo","wgUserGroups":["*","user","autoconfirmed"],"wgCategories":["USB","STM32","Datenübertragung"],"wgPageContentLanguage":"de","wgPageContentModel":"wikitext","wgRelevantPageName":"USB-Tutorial_mit_STM32","wgRelevantArticleId":9686,"wgUserId":22578,"wgUserEditCount":0,"wgUserRegistration":1338920873000,"wgIsProbablyEditable":
!0,"wgRelevantPageIsProbablyEditable":!0,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgSmjUseCdn":!0,"wgSmjUseChem":!0,"wgSmjDisplayMath":[],"wgSmjExtraInlineMath":[],"wgSmjScale":1,"wgSmjEnableMenu":!0,"wgSmjDisplayAlign":"left"};RLSTATE={"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"loading","ext.pygments":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","mediawiki.page.watch.ajax"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@1hzgi",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"patrolToken":"3c37651d0f1248b85e60f00338fbbfc661f1494c+\\","watchToken":"3d766ed023c54d4bfb1800c2d1db539a61f1494c+\\","csrfToken":"27dc4d0ec090e1ce4c4a3ea31e091e6161f1494c+\\"});mw.user.options.set({"contextchars":"50","contextlines":"5","editwidth":0,"highlightbroken":"1","quickbar":"1","skin":""});
});});</script>
<link rel="stylesheet" href="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/load.css">
<script async="" src="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/load.php"></script>
<style>
@media screen {
	.toctoggle{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;font-size:94%}}</style><meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/load_002.css">
<meta name="generator" content="MediaWiki 1.37.0">
<meta name="format-detection" content="telephone=no">
<link rel="alternate" type="application/x-wiki" title="Bearbeiten" href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit">
<link rel="edit" title="Bearbeiten" href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit">
<link rel="shortcut icon" href="https://www.mikrocontroller.net/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="https://www.mikrocontroller.net/opensearch_desc.php" title="Mikrocontroller.net (de)">
<link rel="EditURI" type="application/rsd+xml" href="https://www.mikrocontroller.net/api.php?action=rsd">
<link rel="alternate" type="application/atom+xml" title="Atom-Feed für „Mikrocontroller.net“" href="https://www.mikrocontroller.net/index.php?title=Spezial:Letzte_%C3%84nderungen&amp;feed=atom">
 <meta name="viewport" content="width=device-width,initial-scale=1.0">
<script>
(window.RLQ=window.RLQ||[]).push(function(){
  mw.loader.load( "/assets/application-d6fa7e3fe8a46b7b0f992965cfc59546755c17b327e31d70929902c7d8124df1.js" );
});
</script>
<link rel="stylesheet" media="all" href="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/screen-0b149ad024b430a6039011ee3b7897b77886b19ecaf516531af1b.css">
<link rel="stylesheet" media="print" href="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/print-d245bf6f0a5fe74d9f377c2d91dcaf92e729af0ea914e45fe357de.css">
    <script async="async" src="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/gpt.js"></script>
    <script>
      var googletag = googletag || {};
      googletag.cmd = googletag.cmd || [];
    googletag.cmd.push(function() {
      var mappingRightSidebar = googletag.sizeMapping().addSize([0,0], [300, 250]).addSize([800, 600], [[300, 600], [300, 250], [160, 600]]).build();
      var mappingLeftSidebar = googletag.sizeMapping().addSize([1250, 600], [[160, 600]]).build();
      googletag.pubads().setForceSafeFrame(true);
      googletag.pubads().setRequestNonPersonalizedAds(1);
      googletag.pubads().setSafeFrameConfig({
          allowOverlayExpansion: false,
          allowPushExpansion: false,
          sandbox: true
      });
      googletag.pubads().setPrivacySettings({
        restrictDataProcessing: true,
      });
      googletag.pubads().setTargeting("mikro-categories", []);
      googletag.defineSlot('/62616433/Mikrocontroller_Right_Sidebar_1', [[160, 600], [300, 600], [300, 250]], 'div-gpt-ad-1549487225707-0').defineSizeMapping(mappingRightSidebar).addService(googletag.pubads());
      googletag.defineSlot('/62616433/Mikrocontroller_Left_Sidebar_1', [160, 600], 'div-gpt-ad-1549567092597-0').defineSizeMapping(mappingLeftSidebar).addService(googletag.pubads());
      googletag.pubads().enableSingleRequest();
      googletag.pubads().collapseEmptyDivs();
      googletag.enableServices();
    });
    </script>

<script async="" src="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/js"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}


var gaProperty = 'UA-80574-1';

//
gtag('set', 'ads_data_redaction', true);
//

gtag('js', new Date());
gtag('set', {
  'dimension1': '',
  'dimension2': 'Guest'
});
gtag('config', gaProperty, {
  'anonymize_ip': true,
  'allow_ad_personalization_signals': false,
  'allow_google_signals': false
});
</script>




<script src="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/prompt.js"></script><style type="text/css">.highslide img {cursor: url(highslide/graphics/zoomin.cur), pointer !important;}</style></head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject mw-editable page-USB-Tutorial_mit_STM32 rootpage-USB-Tutorial_mit_STM32 skin-mikrocontroller action-view">
    <!--<script src="/javascripts/highlightCurrentLink.js" type="text/javascript"></script>-->
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mikrocontroller.net/favicon.ico">
    <style type="text/css">#nav-foren-sub {display: none;} </style>
    <style type="text/css">#nav-tutorial-sub {display: none;} </style>

<header>
    <nav class="navbar navbar-default">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed main-menu-toggle" data-toggle="collapse" data-target="#main-nav-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <button type="button" class="navbar-toggle collapsed login-toggle" data-toggle="collapse" data-target="#login-nav-collapse" aria-expanded="false">
                    <span class="glyphicon glyphicon-user"></span>
                </button>
                <button type="button" class="navbar-toggle collapsed search-toggle" data-toggle="collapse" data-target="" aria-expanded="false">
                    <span class="glyphicon glyphicon-search"></span>
                </button>
                <h1>
                    <a href="https://www.mikrocontroller.net/" class="navbar-brand">
                        <img src="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/logo.svg" alt="mikrocontroller.net" class="logo">
                    </a>
                </h1>
                <div class="pull-left mobile-search">
                    <form action="https://www.google.de/cse" class="navbar-form clearfix">
                        <input type="hidden" name="cx" value="partner-pub-1202612203358489:jaffbdxotov">
                        <input type="hidden" name="ie" value="UTF-8">
                        <div class="form-group">
                            <div class="input-group">
                                <span class="input-group-addon search">
                                    <i class="glyphicon glyphicon-search"></i>
                                </span>
                                <input name="q" type="text" class="form-control" placeholder="Suchen">
                                <span class="input-group-addon close-search close-btn">
                                    <i class="glyphicon glyphicon-remove"></i>
                                </span>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
            <div class="collapse navbar-collapse navbar-right" id="login-nav-collapse">
                <ul class="nav navbar-nav hidden-lg visible-xs">
                    <li>
                        <a href="https://www.mikrocontroller.net/user/login">Log in</a>
                    </li>
                    <li>
                        <a href="https://www.mikrocontroller.net/user/register">Join</a>
                    </li>
                </ul>
            </div>

            <div class="collapse navbar-collapse navbar-right" id="main-nav-collapse">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="https://www.mikrocontroller.net/">Neuigkeiten</a>
                    </li>
                    <li class="dropdown main-menu-dropdown">
                        <a href="https://www.mikrocontroller.net/articles/Hauptseite" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Artikel
                            <span class="glyphicon glyphicon-menu-down"></span></a>
                        <div class="dropdown-menu">
                            <div class="container">
                                <ul class="sub-menu">
                                    <li>
                                        <a href="https://www.mikrocontroller.net/articles/AVR"><strong>AVR</strong></a>
                                        <a href="https://www.mikrocontroller.net/articles/AVR-Tutorial">AVR-Tutorial</a>
                                        <a href="https://www.mikrocontroller.net/articles/AVR-GCC-Tutorial">AVR-GCC-Tutorial</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/articles/ARM"><strong>ARM</strong></a>
                                        <a href="https://www.mikrocontroller.net/articles/LPC-Mikrocontroller">LPC</a>
                                        <a href="https://www.mikrocontroller.net/articles/STM32">STM32</a>
                                        <a href="https://www.mikrocontroller.net/articles/Infineon_XMC">XMC</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/articles/MSP430"><strong>MSP430</strong></a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/articles/PIC"><strong>PIC</strong></a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/articles/Programmierbare_Logik"><strong>FPGA, CPLD &amp; Co.</strong></a>
                                        <a href="https://www.mikrocontroller.net/articles/FPGA">Grundlagen zu FPGAs</a>
                                        <a href="https://www.mikrocontroller.net/articles/Hardwarebeschreibungssprachen/">VHDL &amp; Co.</a>
                                        <a href="https://www.mikrocontroller.net/articles/Xilinx_ISE">Xilinx ISE</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/articles/Digitale_Signalverarbeitung"><strong>DSP</strong></a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/articles/Elektronik_Allgemein"><strong>Elektronik allgemein</strong></a>
                                        <a href="https://www.mikrocontroller.net/articles/SMD_L%C3%B6ten">SMD Löten</a>
                                        <a href="https://www.mikrocontroller.net/articles/Operationsverst%C3%A4rker-Grundschaltungen">Operationsverstärker</a>
                                        <a href="https://www.mikrocontroller.net/articles/Oszilloskop">Oszilloskop</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/articles/Hauptseite"><strong>Artikelübersicht
</strong></a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/articles/Spezial:Recentchanges"><strong>Letzte Änderungen</strong></a>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </li>
                    <li class="dropdown main-menu-dropdown open-xs">
                        <a href="https://www.mikrocontroller.net/forum/all" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Forum
                            <span class="glyphicon glyphicon-menu-down"></span></a>
                        <div class="dropdown-menu">
                            <div class="container">
                                <ul class="sub-menu">
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/all"><i class="icons mikro-all"></i> Beiträge in allen Foren</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/mikrocontroller-elektronik"><i class="icons mikro-mikrocontroller-elektronik"></i> µC &amp; Elektronik</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/analogtechnik"><i class="icons mikro-analogtechnik"></i> Analogtechnik</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/fpga-vhdl-cpld"><i class="icons mikro-fpga-vhdl-cpld"></i> FPGA, VHDL &amp; Co.</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/dsp"><i class="icons mikro-dsp"></i> DSP</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/gcc"><i class="icons mikro-gcc"></i>Compiler &amp; IDEs</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/codesammlung"><i class="icons mikro-codesammlung"></i>Projekte &amp; Code</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/markt"><i class="icons mikro-markt"></i>Markt</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/platinen"><i class="icons mikro-platinen"></i>Platinen</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/mechanik"><i class="icons mikro-mechanik"></i>Mechanik &amp; Werkzeug</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/hf"><i class="icons mikro-hf"></i>HF, Funk &amp; Felder</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/fahrzeugelektronik"><i class="icons mikro-fahrzeugelektronik"></i>Fahrzeugelektronik</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/hausbus"><i class="icons mikro-hausbus"></i>Haus &amp; Smart Home</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/pc-programmierung"><i class="icons mikro-pc-programmierung"></i>PC-Programmierung</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/pc-hardware-software"><i class="icons mikro-pc-hardware-software"></i>PC Hard- &amp; Software</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/ausbildung-studium-beruf"><i class="icons mikro-ausbildung-studium-beruf"></i>Ausbildung &amp; Beruf</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/offtopic"><i class="icons mikro-offtopic"></i>Offtopic</a>
                                    </li>
                                    <li>
                                        <a href="https://www.mikrocontroller.net/forum/website"><i class="icons mikro-website"></i>Webseite</a>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </li>
                </ul>
                <form action="https://www.google.de/cse" class="navbar-form navbar-left clearfix hidden-xs" id="cse-search-box">
                    <input type="hidden" name="cx" value="partner-pub-1202612203358489:jaffbdxotov">
                    <input type="hidden" name="ie" value="UTF-8">
                    <div class="form-group">
                        <div class="input-group">
                            <input name="q" type="text" class="form-control" placeholder="Suchen">
                            <span class="input-group-addon">
                                <i class="glyphicon glyphicon-search"></i>
                            </span>
                        </div>
                    </div>
                    <a href="https://www.mikrocontroller.net/user/login">
                        <button type="button" class="btn btn-default login-btn">Login</button>
                    </a>
                </form>
            </div>
        </div>
    </nav>
</header>

	<div id="outer-container">
    <div id="globalWrapper">
  <table id="twocolumns">
  <tbody><tr>
  <td id="sidebar-left" class="sidebar">
  <!-- google_ad_section_start(weight=ignore) -->

<script type="text/javascript">
<!--
    function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
          e.style.display = 'block';
    }
//-->
</script>

	<div id="p-cactions" class="portlet">
	  <h5><a href="#toggle" onclick="javascript:toggle_visibility('p-cactions-box'); return false;">▶ Dieser Artikel</a></h5>
	  <div class="box" id="p-cactions-box">
      <ul>
	    <li id="ca-nstab-main" class="selected"><a href="https://www.mikrocontroller.net/articles/USB-Tutorial_mit_STM32">Seite</a></li><li id="ca-talk" class="new"><a href="https://www.mikrocontroller.net/index.php?title=Diskussion:USB-Tutorial_mit_STM32&amp;action=edit&amp;redlink=1">Diskussion</a></li><li id="ca-edit"><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit">Bearbeiten</a></li><li id="ca-history"><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=history">Versionsgeschichte</a></li><li id="ca-move"><a href="https://www.mikrocontroller.net/articles/Spezial:Verschieben/USB-Tutorial_mit_STM32">Verschieben</a></li><li id="ca-watch" class="mw-watchlink "><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=watch" aria-controls="mw-watchlink-notification">Beobachten</a></li>  	  </ul>
    </div>
	</div>
	<div class="portlet" id="p-personal">
	  <h5><a href="#toggle" onclick="javascript:toggle_visibility('p-personal-box'); return false;">▶ Benutzer</a></h5>
	  <div class="box" id="p-personal-box">
	    <ul>
	    <li id="pt-userpage"><a href="https://www.mikrocontroller.net/articles/Benutzer:Hintiflo">Hintiflo</a></li><li id="pt-mytalk"><a href="https://www.mikrocontroller.net/articles/Benutzer_Diskussion:Hintiflo" class="new">Diskussion</a></li><li id="pt-preferences"><a href="https://www.mikrocontroller.net/articles/Spezial:Einstellungen">Einstellungen</a></li><li id="pt-watchlist"><a href="https://www.mikrocontroller.net/articles/Spezial:Beobachtungsliste">Beobachtungsliste</a></li><li id="pt-mycontris"><a href="https://www.mikrocontroller.net/articles/Spezial:Beitr%C3%A4ge/Hintiflo">Beiträge</a></li>	    </ul>
	  </div>
	</div>
  <!-- LOGO
	<div class="portlet" id="p-logo">
	  <a style="background-image: url(/resources/assets/wiki.png);"
	    href="/articles/Hauptseite"
	    title="Hauptseite"></a>
	</div>
  -->
	<div id="p-search" class="portlet">
	  <h5><a href="#toggle" onclick="javascript:toggle_visibility('p-search-box'); return false;">▶ Suche</a></h5>
	  <div class="box" id="p-search-box">
	    <form name="searchform" action="/articles/Spezial:Suche" id="searchform">
	      <input id="searchInputX" name="search" type="text" accesskey="f"><br>
	      <input type="submit" name="go" class="searchButton" value="Ausführen">&nbsp;<input type="submit" name="fulltext" class="searchButton" value="Suche">
	    </form>
	  </div>
	</div>
	<div class="portlet" id="p-tb">
	  <h5><a href="#toggle" onclick="javascript:toggle_visibility('p-tb-box'); return false;">▶ Werkzeuge</a></h5>
	    <div class="box" id="p-tb-box">
      <ul>
		  		  <li id="t-whatlinkshere"><a href="https://www.mikrocontroller.net/articles/Spezial:Linkliste/USB-Tutorial_mit_STM32">Links auf diese Seite</a></li>
		  		  <li id="t-recentchangeslinked"><a href="https://www.mikrocontroller.net/articles/Spezial:%C3%84nderungen_an_verlinkten_Seiten/USB-Tutorial_mit_STM32">Änderungen an verlinkten Seiten</a></li>
		  	      	      	      	      	      	      	      <li id="t-upload"><a href="https://www.mikrocontroller.net/articles/Spezial:Hochladen">Datei hochladen</a></li>	      	      <li id="t-specialpages"><a href="https://www.mikrocontroller.net/articles/Spezial:Spezialseiten">Spezialseiten</a></li>	      	    </ul>
      </div>
	</div>
  <!-- google_ad_section_end -->
  
  <!-- start adsense -->
    <!-- end adsense -->
  
      </td><!-- end of the left (by default at least) column -->
  <td id="main"><div id="container">
    <!-- google_ad_section_start -->
    <a name="top" id="contentTop"></a>
    		<div id="content">
    <div class="box" id="attention">Willkommen in der 
Mikrocontroller.net Artikelsammlung. Alle Artikel hier können nach dem 
Wiki-Prinzip von jedem bearbeitet werden. <a href="https://www.mikrocontroller.net/articles/">Zur Hauptseite der Artikelsammlung</a></div><h1 class="firstHeading">USB-Tutorial mit STM32</h1>
            <!-- tagline -->
      <div id="siteSub">Aus der Mikrocontroller.net Artikelsammlung, mit Beiträgen verschiedener Autoren (siehe Versionsgeschichte)</div>
      <!-- /tagline -->
      
    <div id="bodyContent">
			<!-- subtitle -->
			<div id="contentSub"></div>
			<!-- /subtitle -->
												<!-- jumpto -->
			<div id="jump-to-nav" class="mw-jump">
				Wechseln zu:				<a href="#mw-navigation">Navigation</a>, 				<a href="#p-search">Suche</a>
			</div>
			<!-- /jumpto -->
						<!-- bodycontent -->
			<div id="mw-content-text" class="mw-body-content mw-content-ltr" dir="ltr" lang="de"><div class="mw-parser-output"><p>Die <a href="https://www.mikrocontroller.net/articles/USB" title="USB">USB</a>-Schnittstelle ist mittlerweile im Consumer-Bereich allgegenwärtig, während aber im Hobby- und auch Industriebereich noch die <a href="https://www.mikrocontroller.net/articles/Kategorie:UART_und_RS232" title="Kategorie:UART und RS232">serielle Schnittstelle</a>
 (RS232/UART) sehr verbreitet ist. Der Grund dafür dürfte hauptsächlich 
in der komplizierteren Implementierung von USB liegen, dafür ist USB 
aber insbesondere für den Anwender deutlich einfacher einzusetzen - ein 
gut umgesetztes USB-Gerät kann nach dem Anschließen ohne jegliche 
Konfiguration oder Installation direkt genutzt werden. Da mittlerweile 
viele direkt USB-fähige Mikrocontroller auch für den Hobby-Entwickler 
verfügbar sind, ist es an der Zeit sich von der seriellen Schnittstelle 
zu verabschieden.
</p>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="https://www.mikrocontroller.net/articles/Datei:USB_LED_Blinker.gif" class="image"><img alt="" src="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/300px-USB_LED_Blinker.gif" decoding="async" class="thumbimage" srcset="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/450px-USB_LED_Blinker.gif 1.5x, USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/USB_LED_Blinker.webp 2x" width="300" height="210"></a>  <div class="thumbcaption"><div class="magnify"><a href="https://www.mikrocontroller.net/articles/Datei:USB_LED_Blinker.gif" class="internal" title="vergrößern"></a></div>Steuerung von LED's vom PC aus via USB und Mikrocontroller, z.B. zur Anzeige der CPU-Last</div></div></div><p>Dafür
 soll in diesem Artikel ein Tutorial zur Entwicklung eines eigenen 
einfachen USB-Geräts gezeigt werden, um dies auch für einfache 
Hobby-Projekte zugänglich zu machen. Als Mikrocontroller wird der <a rel="nofollow" class="external text" href="http://www.st.com/en/microcontrollers/stm32f103rb.html">STM32F103RB</a>
 genutzt, welcher native Unterstützung für USB FullSpeed Devices bietet.
 Um das Verständnis für die Hardware zu fördern und die komplexe und 
eher undurchsichtige USB-Bibliothek des Herstellers selbst zu vermeiden,
 erfolgt der Hardware-Zugriff direkt über die Peripherie-Register. An 
externem Code wird lediglich die Header-Datei mit den 
Registerdefinitionen, sowie der obligatorische Startup-Code und 
Linkerscript verwendet. Somit richtet sich dieses Tutorial an Leser, die
 USB nutzen und dabei auch verstehen möchten, was genau in der Software 
passiert. Für komplexe USB-Geräte oder eine schnelle Implementierung sei
 auf die im <a rel="nofollow" class="external text" href="http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software/stm32cube-embedded-software/stm32cubef1.html">STM32CubeF1</a> enthaltene <a rel="nofollow" class="external text" href="http://www.st.com/resource/en/user_manual/dm00108129.pdf">Bibliothek</a> verwiesen. Es wird Grundlagenwissen über die Programmierung der STM32-Controller und über die C++-Programmierung vorausgesetzt.
</p><p>Zunächst wird ein "USB Hello-World" entwickelt, welches dem PC 
die Steuerung von LEDs ermöglicht sowie in der Art eines "Loopbacks" 
empfangene Daten byteweise umdreht und zurücksendet. Dieses Device 
gehört keiner Standard-Klasse an, sondern wird von einer eigenen 
Anwendung gesteuert. Es wird eine Möglichkeit gezeigt, wie dies auch 
unter aktuellen Windows-Versionen ohne manuelle Treiber-Installation 
oder sonstige Konfiguration gelingt. Als zweites Beispiel erfolgt die 
Implementierung eines 3-fach-Adapters von USB auf die serielle 
Schnittstelle (VCP, Virtual COM Port) auf Basis der Standard-Klasse 
CDC-ACM, was somit ebenfalls ohne Treiber-Installation funktioniert. Als
 weiteres einfaches Beispiel wird eine Firmware gezeigt, welche vom Host
 einen Strom von 500mA anfordert und die Freigabe über einen Pin 
signalisiert, was zur Versorgung eigener Projekte per USB genutzt werden
 kann.
</p><p>Ein Artikel von <a href="https://www.mikrocontroller.net/articles/Benutzer:Erlkoenig" title="Benutzer:Erlkoenig">Niklas Gürtler</a>. Feedback und Fragen können im <a class="external text" href="https://www.mikrocontroller.net/topic/439941">zugehörigen Thread</a> abgegeben werden.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" dir="ltr" lang="de"><h2 id="mw-toc-heading">Inhaltsverzeichnis</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Einleitung"><span class="tocnumber">1</span> <span class="toctext">Einleitung</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#USB-Grundlagen"><span class="tocnumber">1.1</span> <span class="toctext">USB-Grundlagen</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Vergleich_mit_serieller_Schnittstelle"><span class="tocnumber">1.2</span> <span class="toctext">Vergleich mit serieller Schnittstelle</span></a>
<ul>
<li class="toclevel-3 tocsection-4"><a href="#Vorteile_USB"><span class="tocnumber">1.2.1</span> <span class="toctext">Vorteile USB</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="#Vorteile_Serielle_Schnittstelle"><span class="tocnumber">1.2.2</span> <span class="toctext">Vorteile Serielle Schnittstelle</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-6"><a href="#Hardware_&amp;_Beschaltung"><span class="tocnumber">1.3</span> <span class="toctext">Hardware &amp; Beschaltung</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="#Hinweis_zum_&quot;Blue_Bill&quot;_Board"><span class="tocnumber">1.3.1</span> <span class="toctext">Hinweis zum "Blue Bill" Board</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-8"><a href="#Beispielprojekt"><span class="tocnumber">1.4</span> <span class="toctext">Beispielprojekt</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Debugging"><span class="tocnumber">1.5</span> <span class="toctext">Debugging</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Literatur"><span class="tocnumber">1.6</span> <span class="toctext">Literatur</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="#Hello-World_per_USB"><span class="tocnumber">2</span> <span class="toctext">Hello-World per USB</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="#Aktivierung_der_Peripherie"><span class="tocnumber">2.1</span> <span class="toctext">Aktivierung der Peripherie</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Endpoints_&amp;_Puffer"><span class="tocnumber">2.2</span> <span class="toctext">Endpoints &amp; Puffer</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Der_USB-Pufferspeicher"><span class="tocnumber">2.3</span> <span class="toctext">Der USB-Pufferspeicher</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Die_Buffer_Descriptor_Table"><span class="tocnumber">2.4</span> <span class="toctext">Die Buffer Descriptor Table</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Die_EPnR-Register"><span class="tocnumber">2.5</span> <span class="toctext">Die EPnR-Register</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Der_USB-Interrupt"><span class="tocnumber">2.6</span> <span class="toctext">Der USB-Interrupt</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Initial-Konfiguration_beim_Reset"><span class="tocnumber">2.7</span> <span class="toctext">Initial-Konfiguration beim Reset</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Unser_erstes_USB-Paket"><span class="tocnumber">2.8</span> <span class="toctext">Unser erstes USB-Paket</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Transfer-Interrupts"><span class="tocnumber">2.9</span> <span class="toctext">Transfer-Interrupts</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#Der_USB_Device-Deskriptor"><span class="tocnumber">2.10</span> <span class="toctext">Der USB Device-Deskriptor</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="#Kapselung_von_Transfers"><span class="tocnumber">2.11</span> <span class="toctext">Kapselung von Transfers</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#Das_Protokoll_von_Control_Endpoints"><span class="tocnumber">2.12</span> <span class="toctext">Das Protokoll von Control Endpoints</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#Adresszuweisung"><span class="tocnumber">2.13</span> <span class="toctext">Adresszuweisung</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="#Weitere_Standard-Deskriptoren"><span class="tocnumber">2.14</span> <span class="toctext">Weitere Standard-Deskriptoren</span></a>
<ul>
<li class="toclevel-3 tocsection-26"><a href="#Kodierungsfunktionen"><span class="tocnumber">2.14.1</span> <span class="toctext">Kodierungsfunktionen</span></a></li>
<li class="toclevel-3 tocsection-27"><a href="#Konfiguration,_Interface_&amp;_Endpoint"><span class="tocnumber">2.14.2</span> <span class="toctext">Konfiguration, Interface &amp; Endpoint</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="#Deskriptor-Tabelle"><span class="tocnumber">2.14.3</span> <span class="toctext">Deskriptor-Tabelle</span></a></li>
<li class="toclevel-3 tocsection-29"><a href="#String-Deskriptoren"><span class="tocnumber">2.14.4</span> <span class="toctext">String-Deskriptoren</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-30"><a href="#Restliche_Standard-Requests"><span class="tocnumber">2.15</span> <span class="toctext">Restliche Standard-Requests</span></a>
<ul>
<li class="toclevel-3 tocsection-31"><a href="#Vollständige_Enumeration"><span class="tocnumber">2.15.1</span> <span class="toctext">Vollständige Enumeration</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-32"><a href="#Eigene_Requests"><span class="tocnumber">2.16</span> <span class="toctext">Eigene Requests</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#Eigener_Bulk-Endpoint"><span class="tocnumber">2.17</span> <span class="toctext">Eigener Bulk-Endpoint</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-34"><a href="#Eigene_Anwendung_für_PC-Seite"><span class="tocnumber">3</span> <span class="toctext">Eigene Anwendung für PC-Seite</span></a>
<ul>
<li class="toclevel-2 tocsection-35"><a href="#Einbinden_von_LibUsb"><span class="tocnumber">3.1</span> <span class="toctext">Einbinden von LibUsb</span></a>
<ul>
<li class="toclevel-3 tocsection-36"><a href="#Linux"><span class="tocnumber">3.1.1</span> <span class="toctext">Linux</span></a></li>
<li class="toclevel-3 tocsection-37"><a href="#Windows_/_Visual_Studio"><span class="tocnumber">3.1.2</span> <span class="toctext">Windows / Visual Studio</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-38"><a href="#Konfiguration_der_PC-Seite"><span class="tocnumber">3.2</span> <span class="toctext">Konfiguration der PC-Seite</span></a>
<ul>
<li class="toclevel-3 tocsection-39"><a href="#Windows:_Laden_von_WinUSB"><span class="tocnumber">3.2.1</span> <span class="toctext">Windows: Laden von WinUSB</span></a></li>
<li class="toclevel-3 tocsection-40"><a href="#Linux:_Setzen_der_udev-Regeln"><span class="tocnumber">3.2.2</span> <span class="toctext">Linux: Setzen der udev-Regeln</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-41"><a href="#Das_libusb-API"><span class="tocnumber">3.3</span> <span class="toctext">Das libusb-API</span></a>
<ul>
<li class="toclevel-3 tocsection-42"><a href="#Ressourcen-Verwaltung"><span class="tocnumber">3.3.1</span> <span class="toctext">Ressourcen-Verwaltung</span></a></li>
<li class="toclevel-3 tocsection-43"><a href="#Gerät_finden"><span class="tocnumber">3.3.2</span> <span class="toctext">Gerät finden</span></a></li>
<li class="toclevel-3 tocsection-44"><a href="#Gerät_öffnen"><span class="tocnumber">3.3.3</span> <span class="toctext">Gerät öffnen</span></a></li>
<li class="toclevel-3 tocsection-45"><a href="#Abfrage_der_String-Deskriptoren"><span class="tocnumber">3.3.4</span> <span class="toctext">Abfrage der String-Deskriptoren</span></a></li>
<li class="toclevel-3 tocsection-46"><a href="#Control-Transfers"><span class="tocnumber">3.3.5</span> <span class="toctext">Control-Transfers</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-47"><a href="#Vollständige_Umsetzung_von_Control_Endpoints"><span class="tocnumber">4</span> <span class="toctext">Vollständige Umsetzung von Control Endpoints</span></a></li>
<li class="toclevel-1 tocsection-48"><a href="#Virtueller_COM-Port"><span class="tocnumber">5</span> <span class="toctext">Virtueller COM-Port</span></a>
<ul>
<li class="toclevel-2 tocsection-49"><a href="#Deskriptoren_für_CDC"><span class="tocnumber">5.1</span> <span class="toctext">Deskriptoren für CDC</span></a></li>
<li class="toclevel-2 tocsection-50"><a href="#Implementierung_der_Datenübertragung"><span class="tocnumber">5.2</span> <span class="toctext">Implementierung der Datenübertragung</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-51"><a href="#Stromversorgung_per_USB"><span class="tocnumber">6</span> <span class="toctext">Stromversorgung per USB</span></a></li>
</ul>
</div>

<h2 class="mw-header"><a id="Einleitung" href="#Einleitung" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Einleitung</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=1" title="Abschnitt bearbeiten: Einleitung">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3 class="mw-header"><a id="USB-Grundlagen" href="#USB-Grundlagen" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">USB-Grundlagen</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=2" title="Abschnitt bearbeiten: USB-Grundlagen">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Im Folgenden werden knapp die relevanten Basics der USB-Schnittstelle aufgezählt:
</p>
<ul><li>USB wurde ursprünglich für die Verbindung von PCs mit diversen 
Peripheriegeräten entwickelt. Es gibt mehrere Versionen (1.0, 1.1, 2.0, 
3.0, 3.1) die insbesondere unterschiedliche Geschwindigkeiten 
ermöglichen. Im Folgenden wird nur auf USB 2.0 im FullSpeed Modus 
eingegangen, was Geschwindigkeiten bis 12 MBit/Sec ermöglicht. Dies ist 
noch relativ einfach auf Mikrocontrollern umzusetzen.</li>
<li>USB-Geräte sind immer entweder ein "Host" oder ein "Device". "USB 
On-the-Go" (OTG)-Geräte können zwischen den beiden Rollen umschalten. 
Die (logische) Kommunikation erfolgt <i>immer</i> zwischen einem Host und einem Device; Hosts und Devices können untereinander jeweils <i>nicht</i>
 kommunizieren. An einem Host können aber mehrere Devices angeschlossen 
werden. Die meisten PCs haben mehrere USB-Host-Controller (allein schon 
um die unterschiedlichen Standards zu unterstützten), die wiederum meist
 jeweils mehrere USB-Ports versorgen.</li>
<li>In der USB-Spezifikation fest vorgesehen sind USB-Hubs, mit denen 
mehrere Devices an einem Anschluss des Hosts betrieben werden können. 
Mit USB-Hubs kann eine Baumstruktur aufgebaut werden, an deren Wurzel 
der Host steht, deren Blätter die Devices sind und die inneren Knoten 
die Hubs. Es sind <i>keine</i> Kreise möglich. Es handelt sich also um 
eine Stern-Topologie mit mehreren Ebenen (max. 5). Jeder Host kann max. 
127 Geräte nutzen.</li>
<li>Jedes Device "sieht" nur den Host - Hubs und andere Devices sind 
transparent bzw. "unsichtbar". Daher wird im Folgenden von einer 
direkten Kommunikation Host&lt;-&gt;Device ausgegangen.</li>
<li>Es sind diverse Standard-Klassen mit vorgegebenen Protokollen 
definiert, denen Geräte entsprechen können um mit denen bei 
Betriebssystemen mitgelieferten Standard-Treibern zu funktionieren. 
Geräte können sich aber auch als "herstellerspezifisch" anmelden und 
funktionieren dann nur mit eigenen Treibern.</li>
<li>Jedes USB-Gerät wird über zwei fest einprogrammierte 16bit-Zahlen, 
die Vendor ID (VID) und Product ID (PID) identifiziert. Zur Vermeidung 
von Überschneidungen wird die VID vom <a rel="nofollow" class="external text" href="http://usb.org/">USB Implementers Forum</a> verwaltet und vergeben; eine Eigene zu erhalten <a rel="nofollow" class="external text" href="http://www.usb.org/developers/vendor/">kostet</a>
 derzeit einmalig 5000$ oder 4000$ jährlich. Dies ist für 
Hobby-Entwickler wenig realistisch, weshalb bei solchen Projekten oft 
die vorhandene VID eines Herstellers "geborgt" oder eine Fantasie-Zahl 
wie z.B. "0xDEAD" genutzt wird, die vermutlich nie vergeben wird. Dann 
sollte man den Nutzern des Geräts auf jeden Fall ermöglichen, die VID zu
 ändern, falls Kollisionen auftreten. Eine andere Möglichkeit bietet <a rel="nofollow" class="external text" href="http://pid.codes/howto/">pid.codes</a>. Die PID wird vom Hersteller nach Belieben vergeben.</li>
<li>Jegliche Kommunikation wird vom Host aus gesteuert. Der Host sendet 
Daten an Geräte und fragt Daten ab; ein Gerät kann niemals selbstständig
 eine Kommunikation beginnen.</li>
<li>Bis USB 2.0 wird nur eine Datenleitung verwendet, welche aber 
doppelt ausgeführt ist (differentielle Übertragung) und bidirektional 
genutzt wird.</li>
<li>Jedes Gerät hat 1-16 sogenannte "Endpoints", diese sind mit Ports 
bei TCP zu vergleichen. Die Kommunikation läuft im Wesentlichen so ab, 
dass Datenpakete an Endpoints geschickt bzw. von Endpoints abgefragt 
werden. Die Richtung Host-&gt;Device heißt dabei "OUT" und 
Device-&gt;Host heißt "IN". Dies ist aus Sicht der Geräteentwicklung 
etwas verwirrend, sollte aber konsistent beibehalten werden. Die beiden 
Richtungen eines jeden Endpoints können laut USB-Spezifikation 
individuell konfiguriert werden, aber beim hier genutzten STM32F103 
gehören sie eng zusammen. Alle Geräte müssen einen Endpoint 0 haben, 
über den die Kommunikation zum Erkennen und Konfigurieren des Geräts 
abläuft.</li>
<li>Endpoints können verschiedene Typen haben:
<ul><li><b>Bulk</b> Endpoints sind für die Übertragung größerer 
Datenmengen mit garantierter Konsistenz ohne Timing-Anforderung; ähnlich
 einem TCP-Socket. Wird typischerweise bei Speichermedien oder 
virtuellen COM-Ports genutzt.</li>
<li><b>Control</b> Endpoints sind Bulk-Endpoints sehr ähnlich und 
definieren ein auf der Paketübertragung aufbauendes 
Frage-Antwort-Protokoll. Der Endpoint 0 ist immer ein Control Endpoint.</li>
<li><b>Interrupt</b> Endpoints sind für spontane unregelmäßige geringe 
Datenmengen mit garantierter Latenz. Wird z.B. für HID-Geräte genutzt 
(Mäuse, Tastaturen u.a.).</li>
<li><b>Isochronous</b> Endpoints sind für geringe Datenmengen mit fixer 
Timing-Anforderung ohne garantierte Konsistenz, beispielsweise für 
Audio/Video-Anwendungen.</li></ul></li>
<li>Geräte erhalten bei der Verbindung mit dem Host eine neue Adresse im
 Bereich 1-127. Bei der initialen Kommunikation ist die Adresse noch 0.</li>
<li>Der Host kann ein Device zurücksetzen ("reset"). Dies geschieht 
durch ein Ausbleiben der regelmäßig gesendeten "SOF"-Pakete. Das 
geschieht insbesondere beim erstmaligen Anschließen des Geräts.</li>
<li>Zur Kommunikation mit dem Device ist auf Host-Seite ein Treiber 
nötig. Bei den Standard-Klassen sind diese bei den Betriebssystemen 
mitgeliefert. Die Treiberentwicklung ist ein großer Aufwand, 
insbesondere unter Windows ist die erforderliche Signierung eine Hürde. 
Stattdessen kann von Anwendungen aus auch direkt auf die Geräte 
zugegriffen werden:
<ul><li>Der Linux-Kernel stellt dafür via udev die Geräte-Dateien in 
/dev/bus/usb zur Verfügung, auf die von Anwendungen zugegriffen werden 
kann</li>
<li>Unter Windows kann für ein Gerät der "WinUSB"-Treiber geladen 
werden, über dessen API Anwendungen mit Geräten kommunizieren können</li>
<li>Für beide Varianten bietet <a rel="nofollow" class="external text" href="http://libusb.info/">libusb</a> einen Wrapper, welche den plattformunabhängigen einfachen Zugriff auf Geräte ermöglicht. Dies wird auch im Beispiel gezeigt.</li>
<li>Es kann so aber nur eine Anwendung gleichzeitig auf das Gerät zugreifen; diese kann notfalls die Zugriffe weiterleiten.</li></ul></li></ul>
<h3 class="mw-header"><a id="Vergleich_mit_serieller_Schnittstelle" href="#Vergleich_mit_serieller_Schnittstelle" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Vergleich mit serieller Schnittstelle</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=3" title="Abschnitt bearbeiten: Vergleich mit serieller Schnittstelle">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4 class="mw-header"><a id="Vorteile_USB" href="#Vorteile_USB" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Vorteile USB</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=4" title="Abschnitt bearbeiten: Vorteile USB">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul><li>Höhere Geschwindigkeit (hier: 12MBit/Sec)</li>
<li>Einfache Nutzung für Endanwender ("Plug and Play"), keine Konfiguration von Baudrate/Portnummer nötig</li>
<li>Anwendungen können anhand VID/PID direkt das korrekte Gerät finden, 
es muss nicht wie bei der seriellen Schnittstelle der richtige Port 
ausgewählt werden</li>
<li>Stromversorgung der Geräte möglich</li>
<li>Je nach Controller geringerer Hardware-Aufwand als RS-232 (wg. Pegelwandler)</li>
<li>Standard-Treiber für typische Anwendungen im Betriebssystem verfügbar</li>
<li>Das USB-Protokoll teilt den Datenstrom explizit in Pakete ein, im 
Gerät ist direkt klar wo ein Paket anfängt und wo es endet, während man 
bei der seriellen Schnittstelle ein Protokoll benötigt, um Paketanfänge 
zu erkennen (z.B. an Pausen)</li>
<li>USB enthält eine Flusskontrolle, es können in beide Richtungen nur 
Daten gesendet werden, wenn der Empfänger bereit ist. Somit können keine
 Puffer-Überläufe auftreten.</li>
<li>USB erkennt automatisch das Verbinden/Trennen der Gegenstelle, es ist keine manuelle Erkennung per "Ping" o.ä. nötig</li></ul>
<h4 class="mw-header"><a id="Vorteile_Serielle_Schnittstelle" href="#Vorteile_Serielle_Schnittstelle" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Vorteile Serielle Schnittstelle</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=5" title="Abschnitt bearbeiten: Vorteile Serielle Schnittstelle">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul><li>Deutlich einfacher in der Implementierung</li>
<li>Praktisch jeder Controller bietet UART-Module zur Unterstützung der seriellen Schnittstelle</li>
<li>Controller können auch problemlos untereinander direkt kommunizieren (USB-Host Implementierung ist aufwendig)</li>
<li>Gar keine Treiber-Installation nötig</li>
<li>Keine VID/PID nötig</li>
<li>Kommunikation reißt nicht ab, wenn Controller längere Zeit nicht 
antwortet, während USB kurze Timeouts bei der Enumeration hat (Anhalten 
des Controllers z.B. zum Debuggen während der Enumeration führt zu 
sofortiger Abmeldung des Geräts)</li></ul>
<h3 class="mw-header"><a id="Hardware_&amp;_Beschaltung" href="#Hardware_&amp;_Beschaltung" title="Link to this section" class="mw-headline-headanchor"></a><span id="Hardware_.26_Beschaltung"></span><span class="mw-headline">Hardware &amp; Beschaltung</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=6" title="Abschnitt bearbeiten: Hardware &amp; Beschaltung">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Wie die Controller selbst unterscheiden sich auch die 
USB-Peripheriemodule. Die STM32 sind mit drei verschiedenen 
USB-Peripherien verfügbar:
</p>
<ul><li>Das einfach nur <b>USB</b> genannte Modul der kleineren Controller unterstützt nur den Device-Modus und nur FullSpeed.</li>
<li>Das <b>OTG_FS</b>-Modul unterstützt OTG und kann somit auch als Host agieren und ist komplizierter zu programmieren.</li>
<li>Das <b>OTG_HS</b>-Modul unterstützt zusätzlich USB High Speed (480 MBit/Sec).</li></ul>
<p>Hier wird ein Controller mit der einfachsten Variante gewählt, der <a rel="nofollow" class="external text" href="http://www.st.com/en/microcontrollers/stm32f103rb.html">STM32F103RB</a>. Dieser ist beispielsweise auf dem <a rel="nofollow" class="external text" href="https://www.olimex.com/Products/Duino/STM32/OLIMEXINO-STM32/open-source-hardware">Olimexino-STM32</a> zu finden, im Folgenden wird dieses als Grundlage für die Beispiele genutzt. Der auf den  günstigen <a href="https://www.mikrocontroller.net/articles/STM32F103C8T6_STM32_Billig_Board" title="STM32F103C8T6 STM32 Billig Board">Blue Pill</a>-Boards zu findende <a rel="nofollow" class="external text" href="http://www.st.com/en/microcontrollers/stm32f103c8.html">STM32F103C8</a> kann ebenfalls genutzt werden - dazu müssen im Linkerscript die Speichergröße und im Code die genutzten Pins angepasst werden.
</p>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="https://www.mikrocontroller.net/articles/Datei:Olimexino_STM32_USB.png" class="image"><img alt="" src="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/300px-Olimexino_STM32_USB.webp" decoding="async" class="thumbimage" srcset="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/450px-Olimexino_STM32_USB.webp 1.5x, USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/600px-Olimexino_STM32_USB.webp 2x" width="300" height="283"></a>  <div class="thumbcaption"><div class="magnify"><a href="https://www.mikrocontroller.net/articles/Datei:Olimexino_STM32_USB.png" class="internal" title="vergrößern"></a></div>USB-Beschaltung des Olimexino-STM32</div></div></div><p>Bei
 der Entwicklung eigener Platinen kann der Schaltplan das Olimexino als 
Inspiration genutzt werden. Die Pins PA11 und PA12 des Controllers 
müssen mit D- bzw. D+ der USB-Buchse verbunden werden.
</p><p>Die einzig erforderliche zusätzliche Komponente ist der 
1,5kΩ-Widerstand von der USB-Datenleitung D+ nach +3,0V - +3,6V. An 
diesem Widerstand erkennt der Host das angeschlossene Gerät. Wird der 
Widerstand schaltbar ausgeführt, z.B. über einen PNP-Transistor, kann 
das Gerät die Verbindung trennen, aber noch eingeschaltet bleiben. Das 
ist zum Testen praktisch - startet man eine neue Debugging Session, wird
 vor dem Start des Hauptprogramms der Widerstand zunächst abgeschaltet, 
sodass der Host das zuvor ggf. fehlerhaft erkannte Gerät vergisst, und 
dann das neu gestartete Programm erneut ansteuert sobald der Widerstand 
aktiviert ist.
</p><p>Bei der Verwendung von USB ist außerdem ein Quarz Pflicht, damit die Frequenz exakt gehalten werden kann.
</p>
<h4 class="mw-header"><a id="Hinweis_zum_&quot;Blue_Bill&quot;_Board" href="#Hinweis_zum_&quot;Blue_Bill&quot;_Board" title="Link to this section" class="mw-headline-headanchor"></a><span id="Hinweis_zum_.22Blue_Bill.22_Board"></span><span class="mw-headline">Hinweis zum "Blue Bill" Board</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=7" title="Abschnitt bearbeiten: Hinweis zum &quot;Blue Bill&quot; Board">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Beim Blue Pill-Board ist der o.g. Pull-Up Widerstand am USB D+ Pin 
(PA12 am STM32F103) fix verdrahtet und nicht abschaltbar; die 
entsprechenden Code-Zeilen (s.u.) müssen dann entfernt werden. Einige 
neuere Controller haben diesen Widerstand auch schaltbar integriert.
</p><p>Wenn man sich die externe Beschaltung wie oben gezeigt sparen will, bietet sich folgende Lösung an:
</p>
<ul><li>Pin PA12 als Open Drain Output konfigurieren.</li>
<li>Pin per Software auf "0" setzen.</li>
<li>Kurz warten.</li>
<li>Pin wieder als Floating Input konfigurieren.</li></ul>
<p>Das sorgt dafür, dass der externe 1,5kΩ Pull-Up Widerstand kurzzeitig
 über den PA12 Pin nach GND gezogen wird und der USB Host die Bus 
Enumeration neu startet. Die dann über den Pin fließenden I = U / R = 
max. 3.6V / 1.5kΩ = 2.5 mA stellen lt. Datenblatt für den µC kein 
Problem dar.
</p><p><i>Wichtig:</i> Die Sequenz muss ausgeführt werden, bevor der USB
 Transceiver aktiviert wird, d.h. vor der weiter unten gezeigen 
"connect()" Funktion. Der Grund ist, dass der Pin intern automatisch auf
 den USB Core verbunden wird, sobald dieser aktiviert wird (vgl. STM32F1
 CPU Reference Manual RM0008 Rev 20, Seite 168, Sect. 9.1.11, Table 29).
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="w">    </span><span class="c1">// Pin PA12 als Open Drain Output konfigurieren</span>
<span class="w">    </span><span class="n">GPIOA</span><span class="o">-&gt;</span><span class="n">CRH</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="mb">0b11'11</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">GPIOA</span><span class="o">-&gt;</span><span class="n">CRH</span><span class="w"> </span><span class="o">|=</span><span class="w">  </span><span class="p">(</span><span class="mb">0b01'10</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Setze PA12 als "low"</span>
<span class="w">    </span><span class="n">GPIOA</span><span class="o">-&gt;</span><span class="n">ODR</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="mb">0b1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">12</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Kurz warten...</span>
<span class="w">    </span><span class="n">delay</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Pin PA12 wieder als Floating Input konfigurieren.</span>
<span class="w">    </span><span class="n">GPIOA</span><span class="o">-&gt;</span><span class="n">CRH</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="mb">0b11'11</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h3 class="mw-header"><a id="Beispielprojekt" href="#Beispielprojekt" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Beispielprojekt</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=8" title="Abschnitt bearbeiten: Beispielprojekt">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Das Ergebnis dieses Tutorials ist als Beispielprogramm über <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb">GitHub</a> verfügbar. Die vier hier gezeigten Varianten sind dort als einzelne Branches ausgeführt. Der Code ist <b>nicht</b>
 als fertig einzusetzende Bibliothek konzipiert (davon gibt es bereits 
einige), sondern dient der Illustration bei der Durcharbeitung des 
Tutorials. Im Repository sind Projektdateien für die folgenden 
Entwicklungsumgebungen enthalten:
</p>
<ul><li><a rel="nofollow" class="external text" href="https://atollic.com/truestudio/">Atollic TrueSTUDIO Lite</a></li>
<li><a rel="nofollow" class="external text" href="https://www.eclipse.org/cdt/">eclipse-cdt</a> mit <a rel="nofollow" class="external text" href="https://gnu-mcu-eclipse.github.io/">GNU MCU Eclipse-Plugins</a> und <a rel="nofollow" class="external text" href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm">GNU Arm Embedded Toolchain</a> in der Version 6.3.1 (Juni 2017)</li>
<li><a rel="nofollow" class="external text" href="http://www.openstm32.org/">System Workbench for STM32</a></li>
<li><a rel="nofollow" class="external text" href="http://www2.keil.com/mdk5">Keil MDK 5</a> unter Nutzung des Clang-basierten <a rel="nofollow" class="external text" href="http://www2.keil.com/mdk5/compiler/6/">Compiler Version 6</a></li></ul>
<p>Der Beispielcode benötigt einen Compiler mit C++11-Unterstützung, was
 von den aktuellen Versionen der genannten Umgebungen geboten wird. Das 
SW4STM32-Projekt ist für die Nutzung mit dem <a rel="nofollow" class="external text" href="http://www.st.com/en/development-tools/st-link-v2.html">ST-Link</a> konfiguriert, die anderen für den <a rel="nofollow" class="external text" href="https://www.segger.com/products/debug-probes/j-link/">SEGGER J-Link</a>.
 Das kann aber jeweils auch für andere Debugger angepasst werden 
(entsprechende Launch Configurations hinzufügen).
Das Projekt kann als Ausgangspunkt für eigene Modifikationen genutzt 
werden, oder als leere Vorlage durch Löschen der Dateien im "src"-Ordner
 und Neuschreiben des Codes nach diesem Tutorial. Auf GitHub sind auch 
die Kompilate als Binärdateien zum direkten Flashen verfügbar.
</p>
<h3 class="mw-header"><a id="Debugging" href="#Debugging" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Debugging</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=9" title="Abschnitt bearbeiten: Debugging">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Zur Fehlersuche ist dringend die Verwendung eines Debuggers empfohlen, wie z.B. des <a rel="nofollow" class="external text" href="http://www.st.com/content/st_com/en/products/development-tools/hardware-development-tools/development-tool-hardware-for-mcus/debug-hardware-for-mcus/debug-hardware-for-stm32-mcus/st-link-v2.html">ST-Link</a> oder des <a rel="nofollow" class="external text" href="https://www.segger.com/products/debug-probes/j-link/">SEGGER J-Link</a>.
 Breakpoints sind aber mit Vorsicht zu genießen, denn wenn bei der 
Enumerierung eines USB-Geräts dieses angehalten wird und nicht mehr auf 
Anfragen vom Host reagiert, der Host das Gerät als offline ansieht und 
die Verbindung trennt. Ist das Gerät aber erst einmal vollständig 
erkannt, dürfen durchaus Pausen eingelegt werden - ggf. anstehende 
Paket-Transfers müssen dann eben warten.
Die Verwendung von Linux zum Testen ist sinnvoll, weil der Linux-Kernel 
relativ hilfreiche Fehlermeldungen bei sich falsch verhaltenden Geräten 
ausgibt. Diese sind im Kernel-Log zu finden und bspw. über den 
"dmesg"-Befehl abzurufen. Zusätzlich ist <a rel="nofollow" class="external text" href="https://www.wireshark.org/">Wireshark</a>'s
 Fähigkeit, USB-Traffic anzuzeigen, sehr hilfreich. Da dabei auch die 
Daten aller anderen angeschlossenen Geräte mit angezeigt werden, ist es 
sinnvoll, zum Testen ein Notebook zu nutzen, an dem nur das eigene Gerät
 hängt. Bei einem Desktop-PC kann man herausfinden, welche USB-Ports zu 
welchem USB-Host-Controller gehören, und einen Controller ausschließlich
 für das eigene Gerät reservieren.
</p>
<h3 class="mw-header"><a id="Literatur" href="#Literatur" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Literatur</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=10" title="Abschnitt bearbeiten: Literatur">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Dieses Tutorial ist im Endeffekt eine übersichtlichere 
Zusammenstellung vorhandener Informationen. Viele weitere Details finden
 sich in den entsprechenden Dokumenten:
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.st.com/resource/en/datasheet/stm32f103rb.pdf">Datasheet</a> und <a rel="nofollow" class="external text" href="http://www.st.com/resource/en/reference_manual/cd00171190.pdf">Reference Manual</a> des Mikrocontrollers, dort insbesondere das Kapitel 23 über USB.</li>
<li>Die <a rel="nofollow" class="external text" href="http://www.usb.org/developers/docs/usb20_docs/#usb20spec">USB 2.0 -Specification</a>, insbesondere die Datei usb_20.pdf im Archiv.</li>
<li>Die <a rel="nofollow" class="external text" href="http://www.usb.org/developers/docs/devclass_docs/">USB Device Class Specification</a>, speziell die für die Communications Device Class und die darin enthaltene Datei PSTN120.pdf für die CDC-ACM-Spezifikation</li>
<li>Das <a rel="nofollow" class="external text" href="http://libusb.sourceforge.net/api-1.0/">libusb-API</a></li>
<li><a rel="nofollow" class="external text" href="http://www.beyondlogic.org/usbnutshell/usb1.shtml">USB in a NutShell</a> ist eine ausführliche besser als die Spezifikation strukturierte Erläuterung von USB.</li></ul>
<h2 class="mw-header"><a id="Hello-World_per_USB" href="#Hello-World_per_USB" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Hello-World per USB</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=11" title="Abschnitt bearbeiten: Hello-World per USB">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Als erstes wird ein einfaches Testprogramm ohne großen Nutzen 
geschrieben, welches die Grundfunktionalität verdeutlicht. Die erste 
Herausforderung besteht darin, dass sich das Gerät korrekt am Host 
anmelden soll - ist das geschafft, können eigene Funktionen 
implementiert werden. Wir starten zunächst mit einem leeren Projekt, in 
dem die grundlegende Umgebung bereits eingerichtet ist (Linker-Script, 
Startup-Code) und der Haupt-Takt auf 72 MHz konfiguriert ist (Quarz und 
PLL eingeschaltet). Im Beispielprojekt kann hier der Branch "minimal" 
genutzt werden.
</p>
<h3 class="mw-header"><a id="Aktivierung_der_Peripherie" href="#Aktivierung_der_Peripherie" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Aktivierung der Peripherie</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=12" title="Abschnitt bearbeiten: Aktivierung der Peripherie">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Das Einschalten des USB-Peripheriemoduls ist noch recht einfach. 
Zunächst müssen die Peripherietakte und der Pin für den 1,5kΩ-Widerstand
 konfiguriert werden. Die USB-Pins sind im Port A, aber der muss nicht 
aktiviert werden, USB funktioniert auch so.
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Aktiviere USB-Takt</span>
<span class="w">	</span><span class="n">RCC</span><span class="o">-&gt;</span><span class="n">APB1ENR</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">RCC_APB1ENR_USBEN_Msk</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">RCC</span><span class="o">-&gt;</span><span class="n">APB2ENR</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">RCC_APB2ENR_IOPCEN</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Konfiguriere Pin für 1.5kOhm-Widerstand, und schalte Pin auf high, s.d. Widerstand aus ist</span>
<span class="w">	</span><span class="n">GPIOC</span><span class="o">-&gt;</span><span class="n">CRH</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x44474444</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">GPIOC</span><span class="o">-&gt;</span><span class="n">BSRR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPIO_BSRR_BS12</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Schalte USB Interrupt ein</span>
<span class="w">	</span><span class="n">NVIC_EnableIRQ</span><span class="w"> </span><span class="p">(</span><span class="n">USB_LP_CAN1_RX0_IRQn</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Um dann tatsächlich eine Verbindung zu initiieren, muss laut 
Controller-Manual eine bestimmte Sequenz beachtet werden. Das 
standardmäßig aktive Bit "PDWN" im "CNTR" Register wird ausgeschaltet, 
so dass der Transceiver aktiviert wird. Danach müssen wir 1µs warten 
(tSTARTUP). Das wird hier mit einer einfachen Schleife realisiert, 
welche mindestens 72 Takte braucht. Dann kann auch das "FRES" -Bit 
abgeschaltet werden - danach ist die Peripherie sofort bereit. Es müssen
 lediglich noch die Interrupts konfiguriert werden. Wir aktivieren nur 
die Interrupts "CTR" (Transfer abgeschlossen) und "RESET" (Host setzt 
Gerät zurück - passiert normalerweise beim Verbinden). Beide 
Interrupt-Quellen lösen im Interrupt-Controller den selben Interrupt 
aus, den wir auch aktivieren. Zuletzt signalisieren wir dem Host durch 
Einschalten des 1,5kΩ-Widerstands, dass ein Gerät vorhanden ist:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">delay</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">72</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">__NOP</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">connect</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Schalte Transceiver ein, lasse Logik aus</span>
<span class="w">	</span><span class="n">USB</span><span class="o">-&gt;</span><span class="n">CNTR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USB_CNTR_FRES</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Warte auf Hochfahren der analogen Schaltung (tSTARTUP)</span>
<span class="w">	</span><span class="n">delay</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Schalte USB ein, aktiviere Interrupts</span>
<span class="w">	</span><span class="n">USB</span><span class="o">-&gt;</span><span class="n">CNTR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USB_CNTR_CTRM</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_CNTR_RESETM</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Lösche alle Interrupts außer Reset-Interrupt</span>
<span class="w">	</span><span class="n">USB</span><span class="o">-&gt;</span><span class="n">ISTR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USB_ISTR_RESET_Msk</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">NVIC_ClearPendingIRQ</span><span class="w"> </span><span class="p">(</span><span class="n">USB_LP_CAN1_RX0_IRQn</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Schalte 1.5kOhm-Widerstand ein, s.d. Host das Gerät erkennt.</span>
<span class="w">	</span><span class="n">GPIOC</span><span class="o">-&gt;</span><span class="n">BSRR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPIO_BSRR_BR12</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Die beiden gezeigten Funktionen rufen wir von der main() aus auf, und
 starten dann eine Endlosschleifen. Der Linux-Kernel erkennt das 
Vorhandensein des Geräts, und beschwert sich prompt darüber, dass das 
Gerät nicht auf Anfragen antwortet, wie im Syslog zu erkennen ist:
</p>
<pre>[20661.625605] usb 2-2: new full-speed USB device number 17 using xhci_hcd
[20661.737623] usb 2-2: device descriptor read/64, error -71
</pre>
<p>Hier beginnt der schwierige Teil. Wir müssen die Anfragen empfangen und verarbeiten. Doch dazu ist einiges an Vorarbeit nötig.
</p>
<h3 class="mw-header"><a id="Endpoints_&amp;_Puffer" href="#Endpoints_&amp;_Puffer" title="Link to this section" class="mw-headline-headanchor"></a><span id="Endpoints_.26_Puffer"></span><span class="mw-headline">Endpoints &amp; Puffer</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=13" title="Abschnitt bearbeiten: Endpoints &amp; Puffer">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Die USB-Peripherie des genutzten Controllers kann einzelne Pakete 
senden und empfangen, und benachrichtigt die Software per Interrupt über
 dessen Vervollständigung. Um die Daten den einzelnen Endpoints 
zuzuordnen, besitzt die Peripherie 8 Endpoint-Puffer. Jeder dieser 
Puffer wird auf eine Endpoint-Adresse (0-15) eingestellt, und kann dann 
Daten für diesen Endpoint senden und empfangen. Die Endpoint-Puffer sind
 von 0-7 durchnummeriert, aber diese Nummer ist nur für die Software des
 Controllers relevant, und entspricht nicht notwendigerweise der Nummer 
des Endpoints (0-15) auf dem Bus, die auch für den Host sichtbar ist. So
 könnte z.B. Endpoint-Puffer 0 dem Endpoint 7 zugeordnert werden und 
Endpoint-Puffer 5 dem Endpoint 0. Der Typ eines Endpoints wird pro 
Endpoint-Puffer eingestellt, und ein Endpoint-Puffer bearbeitet immer 
beide Richtungen (IN und OUT), somit müssen beide Richtungen vom 
gleichen Typ sein. Dies ist eine Einschränkung des STM32F103 - laut USB 
Spezifikation können die beiden Richtungen auch unterschiedlichen Typs 
sein. Außerdem können eben nur 8 Endpoints genutzt werden und nicht das 
von der Spezifikation vorgegebene Maximum von 16.
</p><p>Jeder Endpoint-Puffer der Nummer <i>i</i> besteht aus zwei Elementen: Eintrag <i>i</i> der Buffer Descriptor Table und das Register EP<i>i</i>R. Diese werden im Folgenden beschrieben.
</p>
<h3 class="mw-header"><a id="Der_USB-Pufferspeicher" href="#Der_USB-Pufferspeicher" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Der USB-Pufferspeicher</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=14" title="Abschnitt bearbeiten: Der USB-Pufferspeicher">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Für den Zugriff auf die empfangenen bzw. zu sendenden Daten wird aber
 nicht wie bei anderen Peripheriemodulen DMA eingesetzt, sondern die 
Peripherie hat ihren eigenen Pufferspeicher. Dieser ist 512 Byte groß 
und wird auch für das CAN-Modul genutzt - daher können USB und CAN nicht
 gleichzeitig verwendet werden. Auf diesen Puffer können wir per 
Software direkt zugreifen, die Hardware simuliert hier einen 
Dual-Port-RAM. Die Struktur des Puffers ist nicht vorgegeben - wir 
müssen der Hardware mitteilen, was wo gespeichert werden soll.
</p>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="https://www.mikrocontroller.net/articles/Datei:STM32F103_USB_Buffer_Mem.svg" class="image"><img alt="" src="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/300px-STM32F103_USB_Buffer_Mem.webp" decoding="async" class="thumbimage" srcset="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/450px-STM32F103_USB_Buffer_Mem.webp 1.5x, USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/600px-STM32F103_USB_Buffer_Mem.webp 2x" width="300" height="103"></a>  <div class="thumbcaption"><div class="magnify"><a href="https://www.mikrocontroller.net/articles/Datei:STM32F103_USB_Buffer_Mem.svg" class="internal" title="vergrößern"></a></div>Schematische Darstellung der Struktur des USB-Pufferspeichers</div></div></div><p>Der
 Zugriff auf den Puffer von der Software-Seite ist etwas unintuitiv: Die
 Hardware sieht den Puffer als eine Folge von 512 Bytes, beginnend ab 
der Adresse 0. Der Prozessorkern und damit die Software sieht den Puffer
 als Folge von 256 16bit-Worten, zwischen denen jeweils eine 16bit-Lücke
 ist, an der nichts gespeichert werden kann. Somit erscheint der Puffer 
der Software als 1024 Bytes groß, wobei die Hälfte Lücken sind. Aus 
Software-Sicht beginnt der Puffer ab Adresse 0x40006000. Im Bild ist 
dies grafisch dargestellt. Beim Schreiben bzw. Lesen von Paket-Daten im 
Pufferspeicher muss dies berücksichtigt werden.
</p><p>Die Einteilung des Pufferspeichers in Bereiche für die einzelnen 
Pakete muss durch die Software vorgenommen werden. Da man sich hier 
schnell verrechnen kann, überlassen wir diese Aufgabe einem Programm, 
das genau darauf optimiert ist: Dem Linker. Dazu legen wir im 
Linker-Script (STM32F103RB.ld) innerhalb des "MEMORY"-Blocks einen 
weiteren Speicherbereich für den USB-Pufferspeicher an:
</p>
<pre>MEMORY {
	FLASH		: ORIGIN = 0x8000000,	LENGTH = 128K
	SRAM		: ORIGIN = 0x20000000,	LENGTH =  20K
	USBBUF		: ORIGIN = 0x40006000,	LENGTH = 1024
}</pre>
<p>Dazu geben wir Größe und Adresse aus Sicht des Prozessors (daher 1024
 Bytes) an. Dann übernehmen wir alle Daten in der Eingabe-Section 
".usbbuf" in diesen Speicher, indem wir folgendes innerhalb der 
"SECTIONS"-Anweisung ablegen:
</p>
<pre>	.UsbBuffer (NOLOAD)&nbsp;: {
		UsbBufBegin = .;
		*(.usbbuf)
		*(.usbbuf*)
	} &gt; USBBUF</pre>
<p>Das NOLOAD sorgt dafür, dass dort abgelegte Daten nicht automatisch 
initialisiert werden. Jetzt können wir im Code globale Variablen anlegen
 und speziell markieren, sodass Compiler &amp; Linker sie in diesem 
Speicherbereich ablegen, d.h. ihnen eine Adresse im gewünschten Bereich 
zuweisen, die beim Zugriff aus dem Code heraus angewendet wird. Da dies 
etwas umständlich ist, definieren wir dafür ein Makro. Das geschieht 
funktioniert dann so:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define USB_MEM __attribute__((section(".usbbuf")))</span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">myBufferData</span><span class="w"> </span><span class="n">USB_MEM</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Zugriffe auf myBufferData werden dann auf den USB-Pufferspeicher 
umgeleitet. Um ganze Pakete ablegen zu können, möchten wir Arrays 
verwenden, bei denen flexibel die Größe geändert werden kann. Dabei muss
 aber für den Software-Zugriff die Lücke nach jedem 16bit-Wort beachtet 
werden. Daher definieren wir eine Klasse "UsbMem":
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">class</span> <span class="nc">UsbMem</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">		</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">		</span><span class="kt">char</span><span class="w"> </span><span class="n">padding</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>Sie ist 4 Bytes groß, aber nur die ersten 2 Bytes sind als 16bit-Wort
 zugänglich. Legen wir davon jetzt ein Array im Pufferspeicher an, 
können wir da unsere Paketdaten hineinschreiben. Dabei ist es aber etwas
 lästig, dass die Größe jetzt in 16bit-Wörtern statt wie üblich in Bytes
 angegeben werden muss. Daher definieren wir eine template-Klasse namens
 "UsbAlloc", welcher die gewünschte Größe in Bytes übergeben wird, und 
die dann ein Array der korrekten Größe enthält. Wie wir später sehen 
werden, unterliegt die Größe weiteren Einschränkungen, damit der Puffer 
genutzt werden kann. Diese überprüfen wir mit static_assert, um das 
Einstellen einer ungültigen Größe zu vermeiden. Den []-Operator 
überladen wir, um den Zugriff zu vereinfachen:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">UsbAlloc</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">static_assert</span><span class="w"> </span><span class="p">(((</span><span class="n">N</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">62</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">N</span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">((</span><span class="n">N</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">512</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)),</span><span class="w"> </span><span class="s">"Invalid reception buffer size requested"</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="c1">/// Das eigentliche Daten-Array</span>
<span class="w">	</span><span class="n">UsbMem</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span><span class="c1">/// Bietet Zugriff auf 16bit-Word "i".</span>
<span class="w">	</span><span class="n">usb_always_inline</span><span class="w"> </span><span class="kt">uint16_t</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>Wenn wir jetzt der Peripherie eine Adresse im Pufferspeicher 
mitteilen möchten, müssen wir die Adresse aus Peripherie-Sicht angeben. 
Wenn wir die Adresse einer solchen Variablen per &amp;-Operator 
abfragen, erhalten wir aber die Adresse aus Prozessor-Sicht. Um diese 
umzurechnen, definieren wir uns eine Hilfsfunktion:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">usb_always_inline</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">mapAddr</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Die Anfangsadresse wird im Linkerscript definiert und hier referenziert.</span>
<span class="w">	</span><span class="k">extern</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">UsbBufBegin</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Ziehe Adresse von Anfangsadresse ab und teile durch 2 um Lücken herauszurechnen.</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">((</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">UsbBufBegin</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Wird ein Zeiger auf eine Variable beliebigen Typs im Pufferspeicher 
übergeben, subtrahiert die Funktion von dieser die Anfangsadresse des 
Pufferspeichers, teilt das Ergebnis durch 2 um die Lücken 
herauszurechnen, und gibt das Resultat als 16bit-Integer zurück.
</p>
<h3 class="mw-header"><a id="Die_Buffer_Descriptor_Table" href="#Die_Buffer_Descriptor_Table" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Die Buffer Descriptor Table</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=15" title="Abschnitt bearbeiten: Die Buffer Descriptor Table">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Damit die Peripherie weiß, wo die Daten eines bestimmten Endpoints 
abgelegt sind, müssen ihr die Adressen und die Größe der selbst 
angelegten Arrays im Pufferspeicher mitgeteilt werden. Dies geschieht 
über die Puffer Descriptor Table, welche für jeden der 8 Endpoint-Puffer
 vier 16bit-Werte speichert:
</p>
<ul><li>Die <b>Transmission buffer address</b> speichert die Startadresse des aktuell zu sendenden Pakets im Pufferspeicher.</li>
<li>Die <b>Transmission byte count</b> gibt die Anzahl an Bytes im zu sendenden Paket an.</li>
<li>Die <b>Reception buffer address</b> gibt die Startaddresse im Pufferspeicher an, an der das aktuell zu empfangende Paket abgelegt werden soll.</li>
<li>Die <b>Reception byte count</b> gibt in einem komprimierten Format 
die Anzahl zu empfangender Bytes sowie die Anzahl tatsächlich 
empfangener Bytes an. Die Anzahl zu empfangender Bytes muss eine der 
folgenden Bedingungen erfüllen:
<ul><li>Sie muss &lt;= 62 <b>und</b> gerade sein</li>
<li>Sie muss &lt;= 512 <b>und</b> ein Vielfaches von 32 sein.</li></ul></li></ul>
<p>Die Buffer Descriptor Table befindet sich selbst auch im 
USB-Pufferspeicher. Damit die Peripherie weiß wo, muss die Adresse im 
Register USB-&gt;BTABLE angegeben werden. In der Tabelle im 
Pufferspeicher sind die 4 16bit-Werte wie erläutert mit 16bit-Lücke 
hintereinander abgelegt, 8 mal hintereinander (einmal pro 
Endpoint-Puffer). Um diese Struktur in Software abzubilden, wird ein 
struct definiert und davon ein acht-elementiges Array angelegt:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">struct</span> <span class="nc">EP_BufDesc</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Anfang des Sendepuffers</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">txBufferAddr</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">Padding1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Größe des Sendepuffers in Bytes</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">txBufferCount</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">Padding2</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Anfang des Empfangspuffers</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">rxBufferAddr</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">Padding3</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Größe und Füllstand des Empfangspuffers; Spezialformat siehe Reference Manual</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">rxBufferCount</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">Padding4</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">alignas</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="n">EP_BufDesc</span><span class="w"> </span><span class="n">BufDescTable</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="n">USB_MEM</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Die vier "Padding"-Variablen sorgen dafür, dass das Layout dem des 
Pufferspeichers mit Lücken entspricht. Per "alignas" wird 
sichergestellt, dass die Adresse des Arrays ein Vielfaches von 8 ist, 
was von der Peripherie gefordert wird. Über BufDescTable[<i>i</i>] kann somit auf die vier Werte von Endpoint-Puffer <i>i</i> zugegriffen werden.
</p>
<h3 class="mw-header"><a id="Die_EPnR-Register" href="#Die_EPnR-Register" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Die EPnR-Register</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=16" title="Abschnitt bearbeiten: Die EPnR-Register">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Zu jedem Endpoint-Puffer gehört eines der acht EPnR-Register (EP0R, 
EP1R, ..., EP7R). Darüber können verschiedene Dinge konfiguriert werden:
</p>
<ul><li>Zustand des Puffers - ob Senden/Empfangen aktiviert ist, und wenn nicht welcher Fehler dem Host signalisiert wird</li>
<li>Typ des Endpoints (Bulk, Control, Isochronous, Interrupt). Gilt für beide Richtungen.</li>
<li>Nummer des Endpoints aus Host-Sicht (0-15).</li></ul>
<p>Es kann abgelesen werden, ob ein Datenpaket komplett 
empfangen/gesendet wurde und ob ein "Setup"-Paket empfangen wurde. 
Außerdem kann für die Übertragung zwischen DATA0/DATA1 umgeschaltet 
werden - dazu später mehr. Im Header von ST sind die EP<i>n</i>R-Register
 nur einzeln definiert (EP0R, EP1R, ...). Wenn der Index des gewünschten
 Registers erst zur Laufzeit bekannt ist, kann man nicht direkt auf das 
Register zugreifen. Daher definieren wir uns ein Array das an die 
richtige Stelle im Adressraum gemappt wird, um darüber komfortabel auf 
die Register per Index zugreifen zu können. Zwischen den einzelnen 
Registern ist je eine 16bit-Lücke, obwohl sich diese nicht im 
USB-Pufferspeicher befinden. Indem die zuvor definierte Klasse "UsbMem" 
im Array wiederverwendet wird, wird die Lücke beim Zugriff übersprungen:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">__IO</span><span class="w"> </span><span class="nf">UsbMem</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">EPnR</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="n">numEP</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">__IO</span><span class="w"> </span><span class="n">UsbMem</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="n">numEP</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">USB_BASE</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Somit entspricht z.B. EPnR[3].data eben EP3R. Die EPnR-Register haben
 noch eine Eigenart: Die verschiedenen Bits werden auf unterschiedliche 
Art geschrieben. Einige Bits bleiben beim Schreiben von 0 unverändert, 
und schalten beim Schreiben von 1 um ("Toggle"). Andere bleiben beim 
Schreiben von 1 unverändert, und werden beim Schreiben von 0 auf 0 
gesetzt. Der Rest verhält sich normal (nimmt den geschriebenen Wert 
direkt an). Um Schreibzugriffe zu vereinfachen, definieren wir uns eine 
Funktion setEPnR, welcher man die gewünschten Endwerte der Bits sowie 
die überhaupt zu schreibenden Bits als Bitmaske übergibt, und die dann 
automatisch die richtige Schreiboperation durchführt:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">setEPnR</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">EP</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">old</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Diese Bits werden beim Schreiben von 0 gelöscht und bleiben bei 1 unverändert.</span>
<span class="w">	</span><span class="k">constexpr</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">rc_w0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USB_EP_CTR_RX_Msk</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_EP_CTR_TX_Msk</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Diese Bits werden beim Schreiben von 1 umgeschaltet, und bleiben bei 0 unverändert.</span>
<span class="w">	</span><span class="k">constexpr</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">toggle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USB_EP_DTOG_RX_Msk</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_EPRX_STAT_Msk</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_EP_DTOG_TX_Msk</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_EPTX_STAT_Msk</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Diese Bits verhalten sich "normal", d.h. der geschriebene Wert wird direkt übernommen.</span>
<span class="w">	</span><span class="k">constexpr</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USB_EP_T_FIELD_Msk</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_EP_KIND_Msk</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_EPADDR_FIELD</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Prüfe zu löschende Bits</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">wr0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">rc_w0</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">data</span><span class="p">));</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Bei Bits mit Umschalte-Verhalten muss der alte Zustand beachtet und per XOR verarbeitet werden</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">wr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">toggle</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">old</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Bei "normalen" Bits wird der alte Zustand beibehalten oder auf Wunsch überschrieben.</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">wr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="n">old</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Kombiniere alle drei Schreibmethoden.</span>
<span class="w">	</span><span class="n">EPnR</span><span class="p">[</span><span class="n">EP</span><span class="p">].</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">wr0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">wr1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">wr2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Ohne eine solche Funktion sind eine Menge Fehler beim Schreiben des Gesamtprogramms vorprogrammiert.
</p>
<h3 class="mw-header"><a id="Der_USB-Interrupt" href="#Der_USB-Interrupt" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Der USB-Interrupt</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=17" title="Abschnitt bearbeiten: Der USB-Interrupt">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Ein Großteil der USB-Ansteuerung wird im von der USB-Peripherie 
ausgelösten Interrupt geschehen. Dort wird das USB-&gt;ISTR Register 
abgefragt, um zu prüfen welches Ereignis aufgetreten wird. Die 
Behandlung wird in eine Schleife verpackt, um während der Verarbeitung 
aufgetretene weitere Ereignisse mit abzufangen:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">/// Globaler Interrupt für die USB-Peripherie.</span>
<span class="k">extern</span><span class="w"> </span><span class="s">"C"</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">USB_LP_CAN1_RX0_IRQHandler</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">ISTR</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Nur diese Interrupts werden verarbeitet</span>
<span class="w">	</span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">interrupts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USB_ISTR_RESET</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_ISTR_CTR</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Bearbeite in einer Schleife so lange aufgetretene Ereignisse, bis die USB Peripherie keine weiteren signalisiert.</span>
<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="p">(((</span><span class="n">ISTR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USB</span><span class="o">-&gt;</span><span class="n">ISTR</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">interrupts</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="c1">// Ein "RESET" tritt auf beim Ausbleiben von Paketen vom Host. Dies ist zu Beginn jeder Verbindung der Fall,</span>
<span class="w">		</span><span class="c1">// bis der Host das Device erkennt.</span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ISTR</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">USB_ISTR_RESET</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="c1">// Lösche Interrupt</span>
<span class="w">			</span><span class="n">USB</span><span class="o">-&gt;</span><span class="n">ISTR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USB_ISTR_PMAOVR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_ISTR_ERR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_ISTR_WKUP</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_ISTR_SUSP</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_ISTR_SOF</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_ISTR_ESOF</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="c1">// ...</span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="c1">// CTR signalisiert die Beendigung eines korrekten Transfers</span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ISTR</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">USB_ISTR_CTR</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="c1">// ...</span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Der Reset-Interupt wird durch schreiben des "USB_ISTR_RESET"-Bits im 
ISTR-Registers auf 0 zurückgesetzt. Indem die anderen Bits auf 1 
geschrieben werden, bleibt ihr aktueller Zustand erhalten. Der 
Transfer-Interrupt wird später über die EPnR-Register quittiert.
</p>
<h3 class="mw-header"><a id="Initial-Konfiguration_beim_Reset" href="#Initial-Konfiguration_beim_Reset" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Initial-Konfiguration beim Reset</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=18" title="Abschnitt bearbeiten: Initial-Konfiguration beim Reset">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Beim vom Host ausgelösten USB-Reset vergisst die USB-Peripherie alle 
vorherigen Einstellungen. Daher müssen wir auf den Reset-Interrupt 
reagieren und dort die Endpoint-Puffer neu konfigurieren. Da dies auch 
beim erstmaligen Verbinden geschieht, brauchen wir woanders keine 
weitere Initialisierung. Da der Host beim Verbinden ein Gerät in einem 
definierten Zustand erwartet, sollten wir in diesem Interrupt auch alle 
weitere Funktionalität des Programms zurücksetzen. Als erstes legen wir 
uns eine globale Variable EP0_BUF an zum Verarbeiten der Pakete auf 
Endpoint 0:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">alignas</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">UsbAlloc</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="w"> </span><span class="n">EP0_BUF</span><span class="w">	</span><span class="n">USB_MEM</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>In die oben gezeigte USB-ISR fügen wir im Abschnitt für den Reset den folgenden Code ein:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Bringe Hard-und Software in definierten Ausgangszustand</span>
<span class="c1">// Mache der Peripherie die Buffer Descriptor Table bekannt</span>
<span class="n">USB</span><span class="o">-&gt;</span><span class="n">BTABLE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mapAddr</span><span class="w"> </span><span class="p">(</span><span class="n">BufDescTable</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Neu verbundene Geräte haben Adresse 0. Speichere diese im USB-Register.</span>
<span class="n">USB</span><span class="o">-&gt;</span><span class="n">DADDR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USB_DADDR_EF</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">USB_DADDR_ADD_Pos</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Anfangsadresse des Empfangspuffers einstellen</span>
<span class="n">BufDescTable</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rxBufferAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mapAddr</span><span class="w"> </span><span class="p">(</span><span class="n">EP0_BUF</span><span class="p">.</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Größe des Empfangspuffers einstellen</span>
<span class="n">BufDescTable</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rxBufferCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x8400</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Endpoint 0 konfigurieren</span>
<span class="n">setEPnR</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">USB_EPRX_STAT_Msk</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_EP_T_FIELD_Msk</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_EPADDR_FIELD</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_EP_KIND</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_EPTX_STAT_Msk</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">USB_EP_RX_VALID</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_EP_TX_NAK</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_EP_CONTROL</span><span class="p">));</span><span class="w"></span>
</pre></div>
<p>Hier wird zunächst der USB-Peripherie die Adresse der Buffer 
Descriptor Table im Pufferspeicher bekannt gemacht. Danach wird in der 
Peripherie die Adresse 0 eingestellt. Dies ist nötig, falls das Gerät 
zwischenzeitlich nicht verbunden war aber die Peripherie von einer 
vorherigen Verbindung noch eine Adresse eingestellt hat. Außerdem wird 
das "USB_DADDR_EF"-Bit gesetzt, um das Peripherie-Modul endgültig 
einzuschalten. Dann wird die Anfangsadresse unseres Empfangspuffers 
EP0_BUF in eine Adresse in Peripherie-Sicht umgerechnet und in die 
Buffer Descriptor Table eingetragen. Dann wird die Größe von 64 Bytes 
(das Maximum für Endpoint 0) über ein spezielles Format eingestellt 
(dazu später mehr). Schließlich wird der Endpoint-Puffer konfiguriert 
und eingeschaltet: Es wird der Typ auf "Control Endpoint" gesetzt, die 
Adresse auf 0 gestellt, das Senden abgeschaltet, und das Empfangen 
aktiviert. In den zweiten if-Block der ISR setzen wir einen Breakpoint 
(z.B. manuell mit "__BKPT();"). Wenn alles funktioniert, wird dieses 
Programm nach dem Einschalten das erste Paket vom Host empfangen.
</p>
<h3 class="mw-header"><a id="Unser_erstes_USB-Paket" href="#Unser_erstes_USB-Paket" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Unser erstes USB-Paket</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=19" title="Abschnitt bearbeiten: Unser erstes USB-Paket">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="https://www.mikrocontroller.net/articles/Datei:Debugging_STM32F103_USB_InitPacket.png" class="image"><img alt="" src="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/300px-Debugging_STM32F103_USB_InitPacket.webp" decoding="async" class="thumbimage" srcset="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/450px-Debugging_STM32F103_USB_InitPacket.webp 1.5x, USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/600px-Debugging_STM32F103_USB_InitPacket.webp 2x" width="300" height="174"></a>  <div class="thumbcaption"><div class="magnify"><a href="https://www.mikrocontroller.net/articles/Datei:Debugging_STM32F103_USB_InitPacket.png" class="internal" title="vergrößern"></a></div>Anzeige des ersten Pakets vom Host beim Debugging</div></div></div><p>Im
 Debugger können wir dann im Empfangsinterrupt das angekommene Paket 
analysieren, indem wir das Array EP0_BUF.data anzeigen lassen (siehe 
Bild). Die ersten beiden Bytes sind also 0x80 und 0x06, darauf folgen 
die 16bit-Werte 0x100, 0 und 0x40. Dies ist einer der Standard-Requests,
 den der Host sendet, um das Gerät zu identifizieren. Die genau 
Bedeutung der Bytes ist in der USB 2.0 Spezifikation auf S. 248 
erläutert. Die ersten zwei Bytes verraten den Typ der Anfrage - es 
handelt sich um "GET_DESCRIPTOR" - dies verwendet der Host, um die 
Eigenschaften des Geräts abzufragen. Da wir hier noch keine Antwort 
senden, beschwert sich der Linux Kernel weiterhin über das Fehlverhalten
 des Geräts. Um aber überhaupt etwas zum Zurücksenden zu haben, müssen 
wir noch mehr Vorarbeit leisten. Andere Betriebssysteme senden ggf. 
zuerst andere Anfragen.
</p><h3 class="mw-header"><a id="Transfer-Interrupts" href="#Transfer-Interrupts" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Transfer-Interrupts</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=20" title="Abschnitt bearbeiten: Transfer-Interrupts">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Bevor wir Daten zurücksenden können, müssen wir die 
Interrupt-Behandlung noch so umbauen, dass korrekt zwischen 
Senden/Empfangen unterschieden wird. Dazu fragen wir das "DIR"-Bit im 
ISTR-Register ab. Ist es 1, wurde etwas empfangen, bei 0 nicht. In 
beiden Fällen wurde ggf. etwas abgesendet. Im EP_ID-Feld des ISTR finden
 wir die Nummer des betreffenden Endpoint-Puffers. Zunächst behandeln 
wir nur Puffer Nr. 0. Im EP0R-Register finden wir dann weitere 
Informationen dazu, was passiert ist: Das CTR_RX-Bit gibt an, ob ein 
empfangender Transfer abgeschlossen wurde, und CTR_TX ist für sendende 
Transfers. Nach dem Abfragen dieser beiden Bits müssen wir sie auf 0 
setzen, aber so dass zwischen Abfragen und Setzen ggf. auftretende 
weitere Ereignisse nicht versehentlich mit gelöscht werden: Dazu 
maskieren wir den aktuellen Inhalt von EP0R via "und" mit 
"USB_EP0R_CTR_RX_Msk | USB_EP0R_CTR_TX_Msk", um die aktuell gesetzten 
Bits zu erhalten. Das übergeben wir an setEPnR, um nur diese Bits auf 0 
zu setzen und zwischenzeitlich auf 1 geänderte Bits zu zu belassen. Bei 
empfangenden Transfers auf dem Endpoint 0 müssen wir noch die Paketdaten
 auseinandernehmen und speichern sie in leichter zu verarbeitende 
Variablen. Insgesamt könnte das dann so aussehen:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// CTR signalisiert die Beendigung eines korrekten Transfers</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ISTR</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">USB_ISTR_CTR</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Richtung des letzten Transfers. false bedeutet "IN" transfer (Device-&gt;Host), true bedeutet "IN" oder "OUT"</span>
<span class="w">	</span><span class="kt">bool</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ISTR</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">USB_ISTR_DIR</span><span class="p">;</span><span class="w"> </span><span class="c1">// 0=TX, 1=RX/TX</span>
<span class="w">	</span><span class="c1">// Die Nummer des EPnR-Registers, welches zu diesem Transfer gehört.</span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">EP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ISTR</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">USB_ISTR_EP_ID</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">USB_ISTR_EP_ID_Pos</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Wir benutzen vorerst nur EP 0</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EP</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="c1">// Frage Zustand dieses Endpoints ab</span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EPnR</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="c1">// Lösche im EPnR-Register die RX/TX-Flags, falls sie gesetzt sind. Falls die Hardware zwischen Abfragen und Löschen</span>
<span class="w">	</span><span class="c1">// eines der Bits setzt, wird dies nicht gelöscht und im nächsten Schleifendurchlauf behandelt.</span>
<span class="w">	</span><span class="n">setEPnR</span><span class="w"> </span><span class="p">(</span><span class="n">EP</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">USB_EP0R_CTR_RX_Msk</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_EP0R_CTR_TX_Msk</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dir</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">USB_EP0R_CTR_RX_Msk</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="c1">// Paket empfangen...</span>
<span class="w">		</span><span class="c1">// Extrahiere die Parameter der Anfrage</span>
<span class="w">		</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">bmRequestType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">EP0_BUF</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">bRequest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">((</span><span class="n">EP0_BUF</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">wValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EP0_BUF</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">		</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">wIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EP0_BUF</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="w">		</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">wLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EP0_BUF</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">USB_EP0R_CTR_TX_Msk</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="c1">// Paket gesendet...</span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Jetzt können wir korrekt auf Empfangs- und Sende-Ereignisse 
reagieren. Das nutzen wir jetzt, um den vom Host angefragten Deskriptor 
zurück zu senden.
</p>
<h3 class="mw-header"><a id="Der_USB_Device-Deskriptor" href="#Der_USB_Device-Deskriptor" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Der USB Device-Deskriptor</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=21" title="Abschnitt bearbeiten: Der USB Device-Deskriptor">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Ein Deskriptor ist ein binär kodierter Datenblock, der Informationen 
über ein Gerät enthält. Jedes USB-Device enthält typischerweise mehrere 
davon, die als Read-Only-Daten abgespeichert sind und vom Host abgerufen
 werden können. Bei manchen Devices, wie z.B. den FT232 
USB-Serial-Adaptern, können über herstellereigene Tools die Deskriptoren
 nachträglich geändert werden. Das Format der Deskriptoren ist von der 
USB-Spezifikation oder anderen darauf aufbauenden Spezifikationen 
jeweils vorgegeben. Das Zustammenstellen der Daten ist ein notwendiges 
Übel, denn es ermöglicht erst die Flexibilität und 
Plug-and-Play-Eigenschaft des USB.
</p><p>Das erste Byte eines jeden Deskriptors gibt dessen Länge in Bytes
 an. Das zweite Byte definiert den Typ des Deskriptors. Die 
entsprechenden Werte für Standard-Deskriptoren sind in der USB 2.0 
Spezifikation auf S. 251 definiert. Die restlichen Einträge sind ab S. 
262 definiert.
Wir fangen mit dem Device Descriptor an indem wir ihn zunächst als 
simples char-Array definieren:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define W(x) (x)&amp;0xFF,(x)&gt;&gt;8</span>
<span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">deviceDescriptor</span><span class="w"> </span><span class="p">[</span><span class="mi">18</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="mi">18</span><span class="p">,</span><span class="w">			</span><span class="c1">// bLength</span>
<span class="w">	</span><span class="mi">1</span><span class="p">,</span><span class="w">			</span><span class="c1">// bDescriptorType: Device</span>
<span class="w">	</span><span class="n">W</span><span class="p">(</span><span class="mh">0x0200</span><span class="p">),</span><span class="w">	</span><span class="c1">// bcdUSB</span>
<span class="w">	</span><span class="mh">0xFF</span><span class="p">,</span><span class="w">		</span><span class="c1">// bDeviceClass: Vendor-specific</span>
<span class="w">	</span><span class="mh">0xFF</span><span class="p">,</span><span class="w">		</span><span class="c1">// bDeviceSubClass: ignored</span>
<span class="w">	</span><span class="mh">0xFF</span><span class="p">,</span><span class="w">		</span><span class="c1">// bDeviceProtocol: ignored</span>
<span class="w">	</span><span class="mi">64</span><span class="p">,</span><span class="w">			</span><span class="c1">// bMaxPacketSize0: allowed: 8,16,32,64</span>
<span class="w">	</span><span class="n">W</span><span class="p">(</span><span class="mh">0xDEAD</span><span class="p">),</span><span class="w">	</span><span class="c1">// idVendor</span>
<span class="w">	</span><span class="n">W</span><span class="p">(</span><span class="mh">0xBEEF</span><span class="p">),</span><span class="w">	</span><span class="c1">// idProduct</span>
<span class="w">	</span><span class="n">W</span><span class="p">(</span><span class="mh">0x0100</span><span class="p">),</span><span class="w">	</span><span class="c1">// bcdDevice</span>
<span class="w">	</span><span class="mi">0</span><span class="p">,</span><span class="w">			</span><span class="c1">// iManufacturer: No string descriptor</span>
<span class="w">	</span><span class="mi">0</span><span class="p">,</span><span class="w">			</span><span class="c1">// iProduct: No string descriptor</span>
<span class="w">	</span><span class="mi">0</span><span class="p">,</span><span class="w">			</span><span class="c1">// iSerialNumber: No string descriptor</span>
<span class="w">	</span><span class="mi">1</span><span class="w">			</span><span class="c1">// bNumConfigurations (must be at least 1)</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>Dabei werden die 16bit-Zahlen in einzelne Bytes aufgeteilt, und das 
Byte mit den weniger signifikanten Stellen zuerst abgelegt (Little 
Endian). Die Lösung mit dem <b>#define W()</b> funktioniert auch in C 
ohne ++, ist flexibel, hat kein Alignment-Problem und verbessert die 
Lesbarkeit - die Bytes muss man trotzdem genau abzählen. Die USB-Version
 wird als 2.0 angegeben. Geräte-Klasse und -Protokoll werden auf 0xFF 
gesetzt, d.h. es wird keine Standard-Klasse genutzt und ein kein 
Standard-Treiber vom Host geladen. Als Paketgröße für Endpoint 0 wählen 
wir das zulässige Maximum von 64 (dazu später mehr). Interessanterweise 
ist dieses Byte bei Offset 7. Denn die minimale zulässige USB-Paketlänge
 beträgt 8 Bytes. Der Host fragt nämlich als allererstes vom <i>deviceDescriptor</i>
 die ersten 8 Bytes ab, um danach mit der wahren FIFO-Größe arbeiten zu 
dürfen. Die bereits erwähnte Vendor ID (Hersteller- oder Verkäufer-ID) 
und Product ID werden hier auf 0xDEAD bzw. 0xBEEF (= „totes 
Rindfleisch“, normalerweise ein <a rel="nofollow" class="external text" href="https://de.wikipedia.org/wiki/Hexspeak">32-Bit-Füllwort</a>
 für ungenutzten Speicher) gesetzt. Stehen eigene ID's zur Verfügung, 
sollten die hier eingesetzt werden. Die drei Zahlen iManufacturer, 
iProduct und iSerialNumber geben Indizes weiterer Deskriptoren an, die 
textuell die jeweilige Angabe enthalten zur Anzeige im 
Host-Betriebssystem; durch 0 signalisieren wir das Fehlen solcher Texte.
 Jedes Gerät muss mindestens eine Konfiguration haben - da wir auch 
nicht mehr brauchen, geben wir bei bNumConfigurations 1 an.
</p><p>Diesen Datenblock müssen wir jetzt auf die Anfrage zurücksenden. 
Dazu werten wir die Parameter der Anfrage aus, um festzustellen, dass 
überhaupt dieser Deskriptor gemeint war. Zudem gibt der Host an, wie 
viele Bytes des Deskriptors gesendet werden sollen - dies ist für solche
 mit variabler Länge nötig. Wir müssen also als Länge das Minimum von 
tatsächlicher und gewünschter Länge nutzen. Dann kopieren wir jeweils 2 
Bytes des Deskriptors in ein 16bit-Wort des Pufferspeichers, und ein 
ggf. einzelnes übrig bleibendes Byte. Schlussendlich können wir das 
Absenden aktivieren, indem wir im EPnR-Register die STAT_TX-Bits auf 
"VALID" setzen. Das könnte etwa so aussehen:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bmRequestType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x80</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">bRequest</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// GET_DESCRIPTOR</span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">((</span><span class="n">wValue</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">wValue</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">wIndex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="c1">// Wie viele Bytes müssen gesendet werden?</span>
<span class="w">		</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="w"> </span><span class="p">(</span><span class="n">wLength</span><span class="p">,</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="n">deviceDescriptor</span><span class="p">)));</span><span class="w"></span>
<span class="w">		</span><span class="c1">// Kopiere Deskriptor-Daten in Pufferspeicher</span>
<span class="w">		</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint_fast16_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">EP0_BUF</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">	</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">deviceDescriptor</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span><span class="w"></span>
<span class="w">						</span><span class="o">|</span><span class="w">	</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">deviceDescriptor</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]}</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">));</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="n">EP0_BUF</span><span class="w"> </span><span class="p">[</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deviceDescriptor</span><span class="w"> </span><span class="p">[</span><span class="n">length</span><span class="mi">-1</span><span class="p">];</span><span class="w"></span>

<span class="w">		</span><span class="c1">// Konfiguriere Sendepuffer in Buffer Descriptor Table</span>
<span class="w">		</span><span class="n">BufDescTable</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">txBufferAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mapAddr</span><span class="p">(</span><span class="n">EP0_BUF</span><span class="p">.</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="n">BufDescTable</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">txBufferCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"></span>

<span class="w">		</span><span class="c1">// Aktiviere Senden</span>
<span class="w">		</span><span class="n">setEPnR</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">USB_EPTX_STAT_Msk</span><span class="p">,</span><span class="w"> </span><span class="n">USB_EP_TX_VALID</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Beim Empfang des Pakets wird der Empfang automatisch abgeschaltet, 
weil ja kein weiterer Speicher zur Verfügung steht. Daher müssen wir 
nach Absenden unserer Antwort den Empfang erneut aktivieren:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">USB_EP0R_CTR_TX_Msk</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Wir haben etwas gesendet. Reaktiviere Empfangspuffer</span>
<span class="w">	</span><span class="n">BufDescTable</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rxBufferAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mapAddr</span><span class="p">(</span><span class="n">EP0_BUF</span><span class="p">.</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">BufDescTable</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rxBufferCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x8400</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">setEPnR</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">USB_EPRX_STAT_Msk</span><span class="p">,</span><span class="w"> </span><span class="n">USB_EP_RX_VALID</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Zu Beachten ist hier: Der Endpoint 0 arbeitet "half-duplex", d.h. es 
werden nie gleichzeitig Daten gesendet und empfangen (obwohl das für 
andere Endpoints möglich ist). Daher können wir den Puffer EP0_BUF 
sowohl zum Senden als auch zum Empfangen nutzen und so etwas Speicher 
sparen.
</p>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="https://www.mikrocontroller.net/articles/Datei:Wireshark_USB_Device_Descriptor.png" class="image"><img alt="" src="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/300px-Wireshark_USB_Device_Descriptor.webp" decoding="async" class="thumbimage" srcset="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/450px-Wireshark_USB_Device_Descriptor.webp 1.5x, USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/600px-Wireshark_USB_Device_Descriptor.webp 2x" width="300" height="239"></a>  <div class="thumbcaption"><div class="magnify"><a href="https://www.mikrocontroller.net/articles/Datei:Wireshark_USB_Device_Descriptor.png" class="internal" title="vergrößern"></a></div>Anzeige des Device-Deskriptors in Wireshark</div></div></div><p>Wird das Gerät jetzt angeschlossen, erhalten wir vom Kernel eine andere Fehlermeldung als zuvor:
</p><pre>[ 4561.749898] usb 2-2: new full-speed USB device number 78 using xhci_hcd
[ 4564.696371] usb 2-2: Device not responding to setup address.
[ 4564.898054] usb 2-2: Device not responding to setup address.
[ 4565.102040] usb 2-2: device not accepting address 78, error -71</pre>
<p>Das ist noch nicht das richtige Erfolgserlebnis. Daher benutzen wir 
Wireshark, um die übertragenen Daten zu betrachten. Die Kommunikation 
mit unserem Gerät befindet sich zwischen einer Reihe an anderen Paketen,
 die nur für den USB-Hub gedacht sind. In der "GET_DESCRIPTOR Response" 
kann der Deskriptor binär in Hex-Form und aufgeschlüsselt nach einzelnen
 Feldern angezeigt werden. Das ist auch später bei komplexeren 
Deskriptoren sehr hilfreich.
</p>
<h3 class="mw-header"><a id="Kapselung_von_Transfers" href="#Kapselung_von_Transfers" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Kapselung von Transfers</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=22" title="Abschnitt bearbeiten: Kapselung von Transfers">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Die ISR besteht jetzt schon aus ziemlichem Spaghetti-Code. Bevor das 
bei der Implementierung weiterer Funktionalität noch viel schlimmer 
wird, sollten wir etwas dagegen tun. Ein probates Mittel zur 
Strukturierung bietet die objektorientierte Programmierung. Zunächst 
verpacken wir die globalen Funktionen zur Konfiguration der 
USB-Peripherie in eine Klasse namens "USBPhys":
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">class</span> <span class="nc">USBPhys</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">		</span><span class="k">constexpr</span><span class="w"> </span><span class="n">USBPhys</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">EPBuffer</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="o">&gt;</span><span class="w"> </span><span class="n">epBuffers</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_epBuffers</span><span class="w"> </span><span class="p">(</span><span class="n">epBuffers</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">		</span><span class="kt">void</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">		</span><span class="kt">void</span><span class="w"> </span><span class="nf">connect</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">		</span><span class="kt">void</span><span class="w"> </span><span class="nf">disconnect</span><span class="w"> </span><span class="p">();</span><span class="w"></span>

<span class="w">		</span><span class="kt">void</span><span class="w"> </span><span class="nf">irq</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">		</span><span class="c1">/// Merkt die Zeiger auf die einzelnen EP-Puffer.</span>
<span class="w">		</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">EPBuffer</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_epBuffers</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">USBPhys</span><span class="w"> </span><span class="nf">usbPhys</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="s">"C"</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">USB_LP_CAN1_RX0_IRQHandler</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">usbPhys</span><span class="p">.</span><span class="n">irq</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Die Funktionen init und connect sind die aus den vorherigen Kapiteln.
 Zur Vollständigkeit wird noch das Komplement "disconnect" hinzugefügt, 
welches die USB-Peripherie sowie den 1,5kΩ-Widerstand abschaltet. Die 
Interrupt-Behandlung verschieben wir in die Funktion "irq", welche dann 
von der eigentlichen ISR aufgerufen wird. Den Zugriff auf die einzelnen 
Endpoint Puffer kapseln wir in eine separate Klasse "EPBuffer". Von 
dieser können bis zu 8 Instanzen angelegt und Zeiger darauf an die 
USBPhys-Klasse übergeben werden:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">enum</span> <span class="k">class</span><span class="w"> </span><span class="nc">EP_TYPE</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">BULK</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">CONTROL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ISOCHRONOUS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">INTERRUPT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="k">class</span> <span class="nc">EPBuffer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">friend</span><span class="w"> </span><span class="k">class</span> <span class="nc">USBPhys</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">		</span><span class="k">constexpr</span><span class="w"> </span><span class="n">EPBuffer</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">iBuffer</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">EP_TYPE</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">UsbMem</span><span class="o">*</span><span class="w"> </span><span class="n">rxBuffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rxBufLength</span><span class="p">,</span><span class="w"> </span><span class="n">UsbMem</span><span class="o">*</span><span class="w"> </span><span class="n">txBuffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">txBufLength</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="o">:</span><span class="w"> </span><span class="n">m_rxBuffer</span><span class="w"> </span><span class="p">(</span><span class="n">rxBuffer</span><span class="p">),</span><span class="w"> </span><span class="n">m_txBuffer</span><span class="w"> </span><span class="p">(</span><span class="n">txBuffer</span><span class="p">),</span><span class="w"> </span><span class="n">m_rxBufLength</span><span class="w"> </span><span class="p">(</span><span class="n">rxBufLength</span><span class="p">),</span><span class="w"> </span><span class="n">m_txBufLength</span><span class="w"> </span><span class="p">(</span><span class="n">txBufLength</span><span class="p">),</span><span class="w"></span>
<span class="w">			  </span><span class="n">m_iBuffer</span><span class="w"> </span><span class="p">(</span><span class="n">iBuffer</span><span class="p">),</span><span class="w"> </span><span class="n">m_address</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="p">),</span><span class="w"> </span><span class="n">m_type</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">		</span><span class="kt">void</span><span class="w"> </span><span class="n">transmitPacket</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="kt">void</span><span class="w"> </span><span class="nf">transmitStall</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">		</span><span class="kt">void</span><span class="w"> </span><span class="nf">receivePacket</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="kt">void</span><span class="w"> </span><span class="nf">getReceivedData</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">protected</span><span class="o">:</span><span class="w"></span>
<span class="w">		</span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">onReset</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">		</span><span class="cm">/**</span>
<span class="cm">		 * Wird von USBPhys aufgerufen, wenn Daten auf diesem Puffer empfangen wurden.</span>
<span class="cm">		 * "setup" gibt an, ob es ein SETUP-Transfer war, und rxBytes die Anzahl</span>
<span class="cm">		 * empfangener Bytes.</span>
<span class="cm">		 */</span><span class="w"></span>
<span class="w">		</span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">onReceive</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">setup</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rxBytes</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="c1">/// Wird von USBPhys aufgerufen, wenn Daten aus diesem Puffer abgesendet wurden.</span>
<span class="w">		</span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">onTransmit</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">		</span><span class="c1">/// Speichert Empfangs-bzw. Sendepuffer.</span>
<span class="w">		</span><span class="n">UsbMem</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">m_rxBuffer</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">m_txBuffer</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="c1">/// Speichert Länge der beiden Puffer.</span>
<span class="w">		</span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">m_rxBufLength</span><span class="p">,</span><span class="w"> </span><span class="n">m_txBufLength</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="c1">/// Speichert Index des Puffers, d.h. Nummer des EPnR-Registers und des BufDescTable-Eintrags.</span>
<span class="w">		</span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">m_iBuffer</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="c1">/// Speichert Bus-Adresse der diesem Puffer zugewiesenen Endpoints.</span>
<span class="w">		</span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">m_address</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="c1">/// Speichert den Typ der Endpoints.</span>
<span class="w">		</span><span class="k">const</span><span class="w"> </span><span class="n">EP_TYPE</span><span class="w"> </span><span class="n">m_type</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>Der Klasse werden zunächst im Konstruktor eine Reihe von fixen 
Einstellungen übergeben. Dies ist der Index des Endpoint Puffers (d.h. 
Nummer des EP<i>n</i>R-Registers), die Nummer des Endpoints auf dem Bus 
("EA" Feld im EPnR), der Typ des Endpoints als enum, sowie Zeiger auf 
Sende-und Empfangspuffer im USB-Pufferspeicher und deren Größe. Für 
half-duplex-Endpoints werden wir hier zweimal den gleichen Puffer 
übergeben. Diese Informationen werden alle in konstanten 
Member-Variablen gespeichert. Die USBPhys-Klasse wird dann <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/master/src/usb.cc#L37">in ihrer "irq"-Funktion</a> über das Zeiger-Array Callbacks in den einzelnen EPBuffer-Instanzen aufrufen:
</p>
<ul><li><a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/minimal/src/usb.cc#L304">onReset</a>
 wird bei einem USB-Reset aufgerufen und reinitialisiert den 
Endpoint-Puffer über das EPnR-Register unter Nutzung der in den 
Member-Variablen abgelegten Informationen.</li>
<li>onReceive wird bei einem empfangenden USB-Transfer aufgerufen unter Übergabe der Anzahl an empfangenden Bytes</li>
<li>onTransmit wird nach Abschluss eines sendenden USB-Transfers aufgerufen.</li></ul>
<p>Die letzten beiden Funktionen sind rein virtuell und müssen von einer
 ableitenden Klasse überschrieben werden. Die weiteren Funktionen sind:
</p>
<ul><li><a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/minimal/src/usb.cc#L219">transmitPacket</a>
 kopiert die übergebenen Daten im "normalen" Speicher in den 
USB-Pufferspeicher und sendet sie ab. Hierhin wird die Schleife von eben
 zum Zusammenfügen zu 16bit-Worten verschoben. Es wird außerdem eine 
Fallunterscheidung eingebaut, um leere Datenpakete senden zu können. Das
 wird später gebraucht.</li>
<li><a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/minimal/src/usb.cc#L257">receivePacket</a>
 bereitet den Empfang von Daten vor. Dazu wird wie eben im 
USB-Reset-Interrupt die Buffer Descriptor Table vorbereitet und der 
Empfang im EPnR-Register aktiviert. Es kann auch der Empfang leerer 
Datenpakete angefordert werden - in diesem Fall wird die Peripherie so 
konfiguriert, dass sie bei nichtleeren Paketen einen Fehler 
zurücksendet. Auch das wird später gebraucht.</li>
<li><a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/minimal/src/usb.cc#L285">getReceivedData</a> kopiert empfangene Daten aus dem USB-Pufferspeicher in normalen Speicher.</li>
<li><a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/minimal/src/usb.cc#L247">transmitStall</a>
 konfiguriert den Endpoint-Puffer so, dass wenn der Host das nächste Mal
 versucht Daten abzuholen ("IN"), das Gerät mit "STALL" antwortet. Dies 
signalisiert bei Control Endpoints einen temporären und bei anderen 
Endpoints einen dauerhaften Fehler. Das werden wir später noch brauchen</li></ul>
<p>In receivePacket muss noch beachtet werden, dass die Puffergröße auf 
spezielle Art kodiert werden muss - entweder als Vielfache von 2, oder 
als Vielfache von 32, was über ein separates Bit angegeben wird. Die 
Funktion rechnet die übergebene Anzahl an Bytes in die entsprechende 
Darstellung um. Die beiden gezeigten Klassen bieten eine einfache 
Hardware-Abstraktion: Darauf aufbauender Code muss sich nicht mit den 
Eigenheiten des USB-Pufferspeichers und den sonstigen USB-Registern 
befassen, sondern kann relativ komfortable Funktionen dafür nutzen.
</p>
<h3 class="mw-header"><a id="Das_Protokoll_von_Control_Endpoints" href="#Das_Protokoll_von_Control_Endpoints" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Das Protokoll von Control Endpoints</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=23" title="Abschnitt bearbeiten: Das Protokoll von Control Endpoints">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="https://www.mikrocontroller.net/articles/Datei:Control_Transfers.svg" class="image"><img alt="" src="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/300px-Control_Transfers.webp" decoding="async" class="thumbimage" srcset="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/450px-Control_Transfers.webp 1.5x, USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/600px-Control_Transfers.webp 2x" width="300" height="525"></a>  <div class="thumbcaption"><div class="magnify"><a href="https://www.mikrocontroller.net/articles/Datei:Control_Transfers.svg" class="internal" title="vergrößern"></a></div>Schematische Darstellung von Control-Transfers</div></div></div><p>Die
 bis jetzt implementierte Behandlung von Control Transfers (Abfrage des 
Device Descriptor) könnte jetzt direkt auf Basis der soeben erstellten 
EPBuffer klasse umgebaut werden. Zuvor macht es aber Sinn, sich das hier
 eigentlich implementierte Protokoll genauer anzusehen, um die 
Behandlung von Control Transfers direkt vernünftig zu strukturieren.
</p><p>Ein Protokoll-Transfer beginnt immer mit der <b>Setup-Stage</b>, 
welche aus einem einzelnen "Setup"-Paket vom Host zum Device besteht. 
Setup-Pakete unterschieden sich von normalen "Data OUT" Paketen nur 
durch die Befehlsnummer. Auf dem Controller können wir Setup-Pakete am 
"SETUP"-Bit des EPnR-Registers erkennen. Dieses Bit wird von USBPhys 
ausgelesen und als "setup"-Parameter an EPBuffer::onReceive übergeben. 
Das Setup-Paket enthält Informationen über die gewünschte Operation, die
 wir ja auch bereits ausgewertet haben. Je nach Operation schließt sich 
an die Setup-Stage eine Data-Stage oder direkt eine Status-Stage an.
</p><p>Die <b>Data-Stage</b> besteht aus einer Folge von Paketen die 
alle in die gleiche Richtung gehen und eine beliebig große Datenmenge 
übertragen können. Die gewünschte Richtung geht aus der Art der Anfrage 
hervor. Auf die Data-Stage folgt die Status-Stage.
</p><p>Die Richtung der <b>Status-Stage</b> hängt von der Vorgeschichte 
ab: Kam vorher "IN" Data-Stage, besteht die Status-Stage immer aus einem
 leeren Paket welches der Host an das Device sendet um den ganzen 
Transfer abzuschließen. Nach einer "OUT" Data-Stage oder wenn es keine 
Data-Stage gab, signalisiert das Device in der Status-Stage Erfolg oder 
Misserfolg der gewünschten Operation. Ersteres wird durch Absenden eines
 leeren Datenpakets angezeigt, letzteres durch Senden eines 
"STALL"-Tokens. Dies kann durch einen entsprechenden Wert für die 
STAT_TX-Bits im EPnR-Register erreicht werden.
</p><p>Für unser einfaches "Hello World"-Device brauchen wir nur den 
Fall ohne Data-Stage und nur die "IN"-Data-Stage. Zudem reicht es, in 
der Data-Stage nur ein einzelnes Paket senden zu können, da die hier 
gesendeten Daten in die maximale Paketgröße von 64 passen. Später werden
 wir das ausbauen.
</p><p>Die bis jetzt benötigte rudimentäre Umsetzung von Control 
Transfers verpacken wir in eine extra Klasse, welche von EPBuffer 
ableitet und eigene Callbacks für die einzelnen Stages bietet. Sie ist 
noch sehr einfach, kann dafür aber später leicht erweitert werden.
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">class</span> <span class="nc">ControlEP</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">EPBuffer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">		</span><span class="k">constexpr</span><span class="w"> </span><span class="n">ControlEP</span><span class="w"> </span><span class="p">(...)</span><span class="w"></span>
<span class="w">			</span><span class="o">:</span><span class="w"> </span><span class="n">EPBuffer</span><span class="w"> </span><span class="p">(...),</span><span class="w"> </span><span class="n">m_sendStatus</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">		</span><span class="kt">void</span><span class="w"> </span><span class="n">dataInStage</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="kt">void</span><span class="w"> </span><span class="nf">statusStage</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">success</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">protected</span><span class="o">:</span><span class="w"></span>
<span class="w">		</span><span class="c1">/// Wird aufgerufen, nachdem vom Host ein "Setup" Paket empfangen wurde. Sollte dataInStage oder statusStage aufrufen.</span>
<span class="w">		</span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">onSetupStage</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="cm">/**</span>
<span class="cm">		 * Wird aufgerufen, wenn in der Data Stage alle Daten an den Host gesendet wurden.</span>
<span class="cm">		 * Da bei "In" transfers kein Erfolg signalisiert wird, sollte hier</span>
<span class="cm">		 * statusStage NICHT aufgerufen werden. Kann daher leer gelassen werden.</span>
<span class="cm">		 */</span><span class="w"></span>
<span class="w">		</span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">onDataIn</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="cm">/**</span>
<span class="cm">		 * Wird aufgerufen, wenn ein leeres Datenpaket zur Signalisierung des Erfolgs</span>
<span class="cm">		 * abgesendet wurde (bei Out-Transfers oder solchen ohne Data Stage - in=false),</span>
<span class="cm">		 * oder ein leeres Paket Empfangen wurde (bei In-Transfers - in=true).</span>
<span class="cm">		 */</span><span class="w"></span>
<span class="w">		</span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">onStatusStage</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">		</span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">onReset</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">onReceive</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">setup</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rxBytes</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">final</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">onTransmit</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">final</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">		</span><span class="kt">void</span><span class="w"> </span><span class="n">receiveControlPacket</span><span class="w"> </span><span class="p">();</span><span class="w"></span>

<span class="w">		</span><span class="kt">bool</span><span class="w"> </span><span class="n">m_sendStatus</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>Die Klasse überschreibt die Callbacks von EPBuffer um auf die verschiedenen Ereignisse zu reagieren. Die Funktionen <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/minimal/src/usb.cc#L346">dataInStage</a> und <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/minimal/src/usb.cc#L356">statusStage</a>
 initiieren die jeweilige Stage. Die Klasse ruft die Callbacks onDataIn 
und onStatusStage auf wenn die entsprechenden Stages abgeschlossen 
wurden. Aufgrund der rudimentären Unterstützung der Data-Stage brauchen 
wir nur ein einziges Bit an Zustands-Information: "m_sendStatus" ist 
"false" während der Data-In-Stage, sodass bei <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/minimal/src/usb.cc#L330">onTransmit</a>
 die Status-Stage begonnen wird. Während der Status-Stage ist 
m_sendStatus dann "true", sodass bei onTransmit wieder die nächste 
Setup-Stage vorbereitet werden kann. Das Empfangen von Daten wird 
jeweils durch <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/minimal/src/usb.cc#L340">receiveControlPacket</a> vorbereitet, was <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/minimal/src/usb.cc#L257">EPBuffer::receivePacket</a> aufruft. In <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/minimal/src/usb.cc#L320">onReceive</a>
 können Setup-Pakete direkt zum Nutzer der Klasse weitergeleitet werden -
 bei normalen Paketen wird angenommen es handele sich um die Bestätigung
 in der Status-Stage nach einer Data-In-Stage, weshalb onStatusStage 
aufgerufen wird.
</p>
<h3 class="mw-header"><a id="Adresszuweisung" href="#Adresszuweisung" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Adresszuweisung</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=24" title="Abschnitt bearbeiten: Adresszuweisung">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Von ControlEP leiten wir eine weitere Klasse DefaultControlEP ab, 
welche speziell für Endpoint 0 ist und die von der USB Spezifikation 
definierten Anfragen verarbeitet. Die Klasse überschreibt onSetupStage, 
wohin wir jetzt die Verarbeitung der GET_DESCRIPTOR-Anfrage verschieben.
 Außerdem können wir dort jetzt weitere Anfragen des Hosts verarbeiten. 
Die nächste Anfrage, die der Linux-Kernel sendet, ist SET_ADDRESS 
(bmRequestType = 0, bRequest = 5). Hier wird dem Device eine Adresse im 
Bereich 1-127 zugeordnet. Diese müssen wir an die USB-Peripherie im 
Register USB-&gt;DADDR ablegen, damit die Peripherie auf Anfragen an die
 neue Adresse korrekt reagiert. Das darf aber nicht sofort beim 
Empfangen des Kommandos geschehen, sondern erst <i>nachdem</i> wir die 
Bestätigung in der Status-Stage (leeres Paket) abgesendet haben. Nach 
dem Empfang des Kommandos speichern wir also nur die empfangene Adresse 
in einer Member-Variablen und beginnen die Status-Stage:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bmRequestType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">bRequest</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Merke Adresse; diese wird erst nach Absenden der Bestätigung gesetzt</span>
<span class="w">	</span><span class="n">m_setAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">m_wValue</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x7F</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Sende Bestätigung</span>
<span class="w">	</span><span class="n">statusStage</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Jetzt müssen wir noch die onStatusStage-Funktion überschreiben, um 
die Adresse nach dem Absenden tatsächlich zu übernehmen. Den 
eigentlichen Registerzugriff kapseln wir in USBPhys, damit 
DefaultControlEP hardwareunabhängig bleibt:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">DefaultControlEP::onStatusStage</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Haben wir gerade die Bestätigung für SET_ADDRESS gesendet?</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_setAddress</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="c1">// Jetzt erst die Adresse übernehmen (von Spezifikation vorgegeben)</span>
<span class="w">		</span><span class="n">m_phys</span><span class="p">.</span><span class="n">setAddress</span><span class="w"> </span><span class="p">(</span><span class="n">m_setAddress</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="c1">// Aber nur diesmal</span>
<span class="w">		</span><span class="n">m_setAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">USBPhys::setAddress</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">USB</span><span class="o">-&gt;</span><span class="n">DADDR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">USB_DADDR_EF</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Das "EF"-Bit muss wieder mitgeschrieben werden, um die Peripherie 
eingeschaltet zu lassen. Die Unterscheidung der einzelnen Anfragen in 
onSetupStage implementieren wir mit einer langen if - else - if ... 
Kette. Bei nicht implementierten Anfragen landen wir also im letzten 
else-Zweig, hier sollten wir mit statusStage (false); dem Host einen 
Fehler signalisieren.
</p><p>Starten wir dieses Programm, sieht die Meldung des Kernels schon ganz anders aus:
</p>
<pre>[13292.875740] usb 2-2: new full-speed USB device number 30 using xhci_hcd
[13293.004359] usb 2-2: unable to read config index 0 descriptor/start: -32
[13293.004366] usb 2-2: chopping to 0 config(s)
[13293.004371] usb 2-2: New USB device found, idVendor=dead, idProduct=beef
[13293.004375] usb 2-2: New USB device strings: Mfr=0, Product=0, SerialNumber=0
[13293.004511] usb 2-2: no configuration chosen from 0 choices
</pre>
<p>Im Debugger stellen wir fest, dass der Kernel nach der 
Adresszuweisung (mehrfach) den Device_Qualifier-Deskriptor abfragt.  Das
 darf er, weil das Gerät im Device Deskriptor als USB 2.0 (statt 
1.1)-kompatibel markiert wurde und somit auf diese Anfrage korrekt 
reagieren muss. Dieser Deskriptor ist nur für High-Speed-Geräte relevant
 - ein USB 2.0-kompatibles Full Speed-Gerät muss hier einfach ein 
"STALL" zurücksenden, was wir über "statusStage (false);" erreichen. 
Danach wird der Configuration Descriptor angefragt. Dieser ist auch für 
unser Gerät erforderlich.
</p>
<h3 class="mw-header"><a id="Weitere_Standard-Deskriptoren" href="#Weitere_Standard-Deskriptoren" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Weitere Standard-Deskriptoren</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=25" title="Abschnitt bearbeiten: Weitere Standard-Deskriptoren">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Neben dem Device Deskriptor sind noch weitere Deskriptoren nötig, um 
das Gerät dem Host komplett bekannt zu machen. Dafür sind verschiedene 
Typen von Deskriptoren definiert (Device, Configuration, Interface, 
Endpoint, String ...). Von manchen Deskriptoren kann es Verschiedene 
geben, die über einen Index durchnummeriert werden. Zur vollständigen 
Identifizierung eines Deskriptors sind also Typ und Index nötig. Für 
Detail-Informationen über die einzelnen Einträge der Deskriptoren sei 
wieder auf die USB 2.0 Spezifikation ab S. 261 verwiesen.
</p>
<h4 class="mw-header"><a id="Kodierungsfunktionen" href="#Kodierungsfunktionen" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Kodierungsfunktionen</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=26" title="Abschnitt bearbeiten: Kodierungsfunktionen">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Alle Deskriptoren wie zuvor als "char"-Array zu kodieren ist relativ 
umständlich - insbesondere das Kodieren von Zahlen mit mehr als 8 Bit in
 einzelne Bytes sowie das Zusammenrechnen der Größe von kombinierten 
Deskriptoren ist fehleranfällig. Das manuelle Anlegen von 
UTF-16-Stringdeskriptoren ist wie weiter unten erläutert völlig 
unpraktikabel. Daher befinden sich im Beispielprojekt die Dateien 
"usb_desc_helper.hh" und "encode.hh", welche einige Hilfskonstrukte 
enthalten, die das Erstellen der Deskriptoren vereinfachen. Die 
Definition des zuvor gezeigten Device-Deskriptors sieht damit so aus:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">deviceDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">device</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">			</span><span class="mh">0x200</span><span class="p">,</span><span class="w">		</span><span class="c1">// bcdUSB</span>
<span class="w">			</span><span class="mh">0xFF</span><span class="p">,</span><span class="w">		</span><span class="c1">// bDeviceClass</span>
<span class="w">			</span><span class="mh">0xFF</span><span class="p">,</span><span class="w">		</span><span class="c1">// bDeviceSubClass</span>
<span class="w">			</span><span class="mh">0xFF</span><span class="p">,</span><span class="w">		</span><span class="c1">// bDeviceProtocol</span>
<span class="w">			</span><span class="mi">64</span><span class="p">,</span><span class="w">			</span><span class="c1">// bMaxPacketSize0</span>
<span class="w">			</span><span class="mh">0xDEAD</span><span class="p">,</span><span class="w">		</span><span class="c1">// idVendor		TODO - anpassen</span>
<span class="w">			</span><span class="mh">0xBEEF</span><span class="p">,</span><span class="w">		</span><span class="c1">// idProduct	TODO - anpassen</span>
<span class="w">			</span><span class="mh">0x0100</span><span class="p">,</span><span class="w">		</span><span class="c1">// bcdDevice</span>
<span class="w">			</span><span class="mi">0</span><span class="p">,</span><span class="w">			</span><span class="c1">// iManufacturer, entspricht dem Index des strManufacturer-Deskriptors</span>
<span class="w">			</span><span class="mi">0</span><span class="p">,</span><span class="w">			</span><span class="c1">// iProduct, entspricht dem Index des strProduct-Deskriptors</span>
<span class="w">			</span><span class="mi">0</span><span class="p">,</span><span class="w">			</span><span class="c1">// iSerialNumber, entspricht dem Index des strSerial-Deskriptors</span>
<span class="w">			</span><span class="mi">1</span><span class="w">			</span><span class="c1">// bNumConfigurations</span>
<span class="w">		</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Die Parameter der EncodeDescriptors::USB20::device sind bereits mit 
den richtigen Typen definiert, d.h. bcdUSB, idVendor, idProduct und 
bcdDevice sind uint16_t. Größe und Typ des Deskriptors müssen nicht 
angegeben werden, weil diese ohnehin immer gleich sind. Die Funktion 
gibt ein std::array&lt;uint8_t,18&gt; zurück, welches später simpel 
byteweise in den USB-Pufferspeicher kopiert werden kann. Durch 
Markierung mit "constexpr" wird der Compiler dieses Array während des 
Kompilier-Vorgangs berechnen und das Ergebnis als Konstante in den Flash
 legen - so wird kein RAM oder Rechenzeit zum Zusammenstellen dieser 
Daten benötigt.
Diese Funktionen nutzen intern eine relativ komplexe Logik auf Basis von
 Metaprogrammierung. Daher wird die Funktionsweise hier nicht genauer 
erläutert. Für den Fall, dass diese Konstruktion nicht genutzt werden 
kann, sind im Beispielcode die Deskriptoren in Kommentaren als simple 
Arrays hinterlegt.
</p>
<h4 class="mw-header"><a id="Konfiguration,_Interface_&amp;_Endpoint" href="#Konfiguration,_Interface_&amp;_Endpoint" title="Link to this section" class="mw-headline-headanchor"></a><span id="Konfiguration.2C_Interface_.26_Endpoint"></span><span class="mw-headline">Konfiguration, Interface &amp; Endpoint</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=27" title="Abschnitt bearbeiten: Konfiguration, Interface &amp; Endpoint">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Wie bereits erwähnt müssen wir einen Configuration Deskriptor 
erstellen. Aber was ist überhaupt eine Konfiguration? Die USB 
Spezifikation verlangt, dass jedes Gerät mindestens eine Konfiguration 
besitzt, und der Host das Gerät anweisen kann, zwischen verschiedenen 
Konfigurationen umzuschalten. Es ist immer genau eine Konfiguration 
aktiv. Konfigurationen repräsentieren also eine Art "Betriebsmodus". 
Unser einfaches Hello-World-Programm wird nur eine einzelne 
Konfiguration anbieten.
</p><p>Jede Konfiguration muss mindestens ein Interface bieten. Alle 
Interfaces einer Konfiguration sind gleichzeitig aktiv, aber für jedes 
Interface kann es sogenannte Alternative Settings geben, zwischen denen 
umgeschaltet werden kann ähnlich wie zwischen verschiedenen 
Konfigurationen. Ein Interface bietet Zugriff auf eine Funktion oder 
einen funktionalen Aspekt eines Geräts; Multifunktionsgeräte nutzen 
daher mehrere davon. Für unser Programm reicht ein einzelnes Interface 
ohne Alternate Settings aus.
</p><p>Jedes Interface kann 0 oder mehr Endpoints haben, über welche die
 Funktionalität dieses Interfaces genutzt werden kann. Der Default 
Control Endpoint 0 gehört automatisch zu allen Interfaces. 
</p><p>Pro Konfiguration muss das Gerät einen Configuration Descriptor 
haben. Jeder davon setzt sich aus einer Folge mehrerer einzelner Blöcke 
zusammen:
</p>
<ul><li>Zuerst kommt der eigentliche Configuration Descriptor als "Header"</li>
<li>Für jedes Interface folgt ein Interface Descriptor</li>
<li>Nach jedem Interface Descriptor folgen 0 oder mehr Endpoint Descriptors, einer pro Endpoint und pro Richtung (IN/OUT).</li></ul>
<p>Die interessanteste Angabe im Configuration Descriptor ist der Strom,
 den das Gerät benötigt und den der Host zur Verfügung stellen muss. 
Dieser wird in 2mA-Schritten angegeben (0-500mA). Im Interface 
Descriptor wird u.a. die Klasse und Protokoll des Interface definiert. 
Diese ist von der Geräteklasse abhängig, und gibt bei Geräten mit 
mehreren Interfaces an, welches Interface welche Funktion bietet. Im 
Endpoint Descriptor werden Typ und Adresse definiert und die <i>maximale</i>
 Paketgröße. Diese muss konsistent mit dem Programm sein: Wenn das 
Programm versucht ein größeres Paket zu senden, oder (temporär) nur 
kleinere Pakete akzeptiert, schlägt die Kommunikation komplett fehl. In 
der Adresse wird jeweils die Richtung im höchsten Bit mit angegeben.
</p><p>Die einzelnen Deskriptoren für Interfaces und Endpoints werden 
über die Funktionen EncodeDescriptors::USB20::interface und 
EncodeDescriptors::USB20::endpoint angelegt. Deren Rückgabewerte werden 
dann an EncodeDescriptors::USB20::configuration übergeben, welches sie 
zusammen mit den Daten für den Configuration Descriptor zu einem großen 
Datenblock zusammenfügt. Wir definieren uns also einen Configuration 
Descriptor, einen Interface Descriptor und zwei Endpoint Descriptors für
 beide Richtungen eines Bulk-Endpoints mit Adresse 1, mit welchem wir 
später unsere eigene Funktionalität umsetzen werden:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">confDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">configuration</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">			</span><span class="mi">1</span><span class="p">,</span><span class="w">			</span><span class="c1">// bNumInterfaces</span>
<span class="w">			</span><span class="mi">1</span><span class="p">,</span><span class="w">			</span><span class="c1">// bConfigurationValue</span>
<span class="w">			</span><span class="mi">0</span><span class="p">,</span><span class="w">			</span><span class="c1">// iConfiguration</span>
<span class="w">			</span><span class="mh">0x80</span><span class="p">,</span><span class="w">		</span><span class="c1">// bmAttributes</span>
<span class="w">			</span><span class="mi">250</span><span class="p">,</span><span class="w">		</span><span class="c1">// bMaxPower (500mA)</span>

<span class="w">			</span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">interface</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">				</span><span class="mi">0</span><span class="p">,</span><span class="w">		</span><span class="c1">// bInterfaceNumber</span>
<span class="w">				</span><span class="mi">0</span><span class="p">,</span><span class="w">		</span><span class="c1">// bAlternateSetting</span>
<span class="w">				</span><span class="mi">2</span><span class="p">,</span><span class="w">		</span><span class="c1">// bNumEndpoints</span>
<span class="w">				</span><span class="mh">0xFF</span><span class="p">,</span><span class="w">	</span><span class="c1">// bInterfaceClass</span>
<span class="w">				</span><span class="mh">0xFF</span><span class="p">,</span><span class="w">	</span><span class="c1">// bInterfaceSubClass</span>
<span class="w">				</span><span class="mh">0xFF</span><span class="p">,</span><span class="w">	</span><span class="c1">// bInterfaceProtocol</span>
<span class="w">				</span><span class="mi">0</span><span class="w">		</span><span class="c1">// iInterface</span>
<span class="w">			</span><span class="p">),</span><span class="w"></span>
<span class="w">			</span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">endpoint</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">				</span><span class="mi">1</span><span class="p">,</span><span class="w">		</span><span class="c1">// bEndpointAddress</span>
<span class="w">				</span><span class="mi">2</span><span class="p">,</span><span class="w">		</span><span class="c1">// bmAttributes</span>
<span class="w">				</span><span class="mi">64</span><span class="p">,</span><span class="w">		</span><span class="c1">// wMaxPacketSize</span>
<span class="w">				</span><span class="mi">10</span><span class="w">		</span><span class="c1">// bInterval</span>
<span class="w">			</span><span class="p">),</span><span class="w"></span>
<span class="w">			</span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">endpoint</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">				</span><span class="mh">0x81</span><span class="p">,</span><span class="w">	</span><span class="c1">// bEndpointAddress</span>
<span class="w">				</span><span class="mi">2</span><span class="p">,</span><span class="w">		</span><span class="c1">// bmAttributes</span>
<span class="w">				</span><span class="mi">64</span><span class="p">,</span><span class="w">		</span><span class="c1">// wMaxPacketSize</span>
<span class="w">				</span><span class="mi">10</span><span class="w">		</span><span class="c1">// bInterval</span>
<span class="w">		</span><span class="p">)</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
</pre></div>
<h4 class="mw-header"><a id="Deskriptor-Tabelle" href="#Deskriptor-Tabelle" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Deskriptor-Tabelle</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=28" title="Abschnitt bearbeiten: Deskriptor-Tabelle">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Um diesen Deskriptor abfragen zu können, könnten wir nun in die 
Verarbeitung der GET_DESCRIPTOR-Anfrage eine Fallunterscheidung 
einbauen, die beim richtigen Befehl die neuen Daten zurücksendet. Das 
wird aber bei steigender Zahl an Deskriptoren umständlich und schlecht 
wartbar. Daher erstellen wir eine einfache Klasse "Descriptor", welche 
einen Zeiger auf die (konstanten) Deskriptor-Daten enthält, sowie Größe,
 Typ (als enum) und Index:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">enum</span> <span class="k">class</span><span class="w"> </span><span class="nc">D_TYPE</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="p">{</span><span class="w">	</span><span class="n">DEVICE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">CONFIGURATION</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">STRING</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">INTERFACE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">ENDPOINT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE_QUALIFIER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">OTHER_SPEED_CONFIGURATION</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">INTERFACE_POWER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Descriptor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">	</span><span class="k">constexpr</span><span class="w"> </span><span class="n">Descriptor</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Util</span><span class="o">::</span><span class="n">EncChar</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">data_</span><span class="p">,</span><span class="w"> </span><span class="n">D_TYPE</span><span class="w"> </span><span class="n">type_</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">index_</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="n">data_</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="p">(</span><span class="n">type_</span><span class="p">),</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="p">(</span><span class="n">index_</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">	</span><span class="k">const</span><span class="w"> </span><span class="n">Util</span><span class="o">::</span><span class="n">EncChar</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">D_TYPE</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>Durch Ausführung des Konstruktors als template kann direkt ein 
std::array übergeben werden und die Größe wird automatisch übernommen. 
Davon können wir jetzt eine Tabelle anlegen, in der alle Deskriptoren 
aufgelistet sind, sowie eine Funktion um diese zu durchsuchen anhand des
 gewünschten Typ und Index:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">Descriptor</span><span class="w"> </span><span class="n">descriptors</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">deviceDescriptor</span><span class="p">,</span><span class="w"> </span><span class="n">D_TYPE</span><span class="o">::</span><span class="n">DEVICE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">									</span><span class="p">{</span><span class="w"> </span><span class="n">confDescriptor</span><span class="p">,</span><span class="w"> </span><span class="n">D_TYPE</span><span class="o">::</span><span class="n">CONFIGURATION</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">Descriptor</span><span class="o">*</span><span class="w"> </span><span class="nf">getUsbDescriptor</span><span class="w"> </span><span class="p">(</span><span class="n">D_TYPE</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Durchsuche Deskriptor-Tabelle</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="nl">d</span> <span class="p">:</span><span class="w"> </span><span class="n">descriptors</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Bei der GET_DESCRIPTOR-Anfrage wird im Parameter "wValue" im oberen 
Byte der gewünschte Typ, und im unteren der gewünschte Index abgegeben 
(meistens 0). In wIndex wird die Sprache angegeben. Wenn nur eine 
Sprache unterstützt wird, kann man dies ignorieren. Anhand dieser Daten 
kann dann der Deskriptor abgefragt und zurückgesendet werden:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_bmRequestType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x80</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">m_bRequest</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Deskriptor-Typ aus Anfrage extrahieren</span>
<span class="w">	</span><span class="n">D_TYPE</span><span class="w"> </span><span class="n">descType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">D_TYPE</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">m_wValue</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Deskriptor-Index aus Anfrage extrahieren</span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">descIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">m_wValue</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Durchsuche Deskriptor-Tabelle</span>
<span class="w">	</span><span class="k">const</span><span class="w"> </span><span class="n">Descriptor</span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getUsbDescriptor</span><span class="w"> </span><span class="p">(</span><span class="n">descType</span><span class="p">,</span><span class="w"> </span><span class="n">descIndex</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="c1">// Kein passender Deskriptor - sende Fehler</span>
<span class="w">		</span><span class="n">statusStage</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="c1">// Sende nur max. so viel wie gefordert. Falls Deskriptor länger ist, wird der Host eine erneute Anfrage des</span>
<span class="w">		</span><span class="c1">// ganzen Deskriptors stellen, dessen Gesamtlänge immer ganz zu Beginn steht und somit nach der 1. Anfrage</span>
<span class="w">		</span><span class="c1">// bekannt ist.</span>
<span class="w">		</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">m_wLength</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="c1">// Sende Deskriptor</span>
<span class="w">		</span><span class="n">dataInStage</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Wird das um den Configuration Descriptor aufgerüstete Programm gestartet, erhalten wir die folgende Ausgabe von Linux:
</p>
<pre>[ 2156.256928] usb 2-2: new full-speed USB device number 13 using xhci_hcd
[ 2156.385534] usb 2-2: New USB device found, idVendor=dead, idProduct=beef
[ 2156.385538] usb 2-2: New USB device strings: Mfr=0, Product=0, SerialNumber=0
[ 2156.386382] usb 2-2: can't set config #1, error -32
</pre>
<p>Es gibt keine Beschwerde über den Configuration Descriptor mehr; 
stattdessen fehlen uns aber noch die Behandlung weiterer Anfragen.
</p>
<h4 class="mw-header"><a id="String-Deskriptoren" href="#String-Deskriptoren" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">String-Deskriptoren</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=29" title="Abschnitt bearbeiten: String-Deskriptoren">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Wo wir gerade mit Deskriptoren beschäftigt sind, können wir noch ein 
paar String-Deskriptoren hinzufügen. Wie der Name andeutet, enthalten 
diese einen menschenlesbaren Text der zur Anzeige im Host-Betriebssystem
 gedacht ist und keine technische Bedeutung hat. String-Deskriptoren 
werden über einen Index identifiziert, und jeder davon kann in 
mehrfacher Ausfertigung existieren für verschiedene Sprachen. Im String 
mit Nr. 0 wird statt eines Textes die "Language Table" angegeben, eine 
Aufzählung der unterstützten Sprachen. Diese besteht aus einer Folge von
 16bit-Integern, welche die unterstützten <a rel="nofollow" class="external text" href="http://www.usb.org/developers/docs/USB_LANGIDs.pdf">Sprach-Codes</a> angeben. Wir werden nur Deutsch einbauen:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">langTable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">languageTable</span><span class="w"> </span><span class="p">(</span><span class="mh">0x0407</span><span class="w"> </span><span class="cm">/* German (Standard) */</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Die eigentlichen Strings werden in Unicode via UTF-16 kodiert, d.h. 
jedes Zeichen besteht aus einem oder mehr 16bit-Werten, wobei das 
niederwertige Byte jeweils zuerst kommt (Little Endian). Somit können 
Zeichen in (fast) allen Sprachen der Welt angegeben und vermischt 
werden. Die Kodierung stellt uns vor ein unerwartetes Problem: Es wäre 
sinnvoll, die Strings direkt im geforderten UTF-16 LE-Format im Flash 
abzulegen und dann 1:1 abzuschicken, andererseits möchten wir die Texte 
gerne als String-Literale im Code angeben, damit sie leicht les-und 
änderbar sind. Leider werden Quelltext-Dateien meistens als UTF-8 
kodiert, und eine Umwandlung der Quelltextdatei nach UTF-16 ist kaum 
praktikabel weil dann auch alle Header-Dateien (inkl. der 
System-Header!) mit konvertiert werden müssten. Seit C++11 ist es aber 
möglich, explizit UTF-16-Stringliterale anzugeben, indem vor die 
öffnenden Anführungsstriche einfach ein kleines(!) "u" vorangestellt 
wird (großes "U" ist für UTF-32). Der Typ des Literals ist dann "const 
char16_t []", d.h. der Compiler hat bereits die Konvertierung vom 
Quellcode-Format (welches auch immer eingestellt ist) in 16bit-Worte 
vorgenommen. Diese müssen wir jetzt noch in Einzel-Bytes der richtigen 
Reihenfolge (Little Endian) umwandeln. Dafür ist in der "encode.hh" die 
Funktion Util::encodeString definiert, welche aus einem String-Literal 
ein std::array&lt;uint8_t, ...&gt; macht:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Util</span><span class="o">::</span><span class="n">encode</span><span class="p">(</span><span class="sa">u</span><span class="s">"Der Gerät"</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Im Flash landet dann die UTF-16-Kodierung. Ein alternatives Vorgehen 
besteht in der manuellen Berechnung der einzelnen Werte der Bytes und 
Definition des Strings als Array, was aber sehr umständlich ist. Etwas 
vereinfachen kann man sich das indem man die Texte in einem Text-Editor 
in einer Datei als UTF-16 speichert und sich das Ergebnis im Hex-Editor 
ansieht. Im Beispiel-Code von ST werden die String-Literale klassisch im
 ASCII-Format angegeben, und dann vor dem Senden nach UTF-16 
konvertiert, indem nach jedem Byte ein 0-Byte eingefügt wird. Dabei ist 
aber die Nutzung von Nicht-ASCII-Zeichen (z.B. Umlaute) nicht möglich 
und es wird zusätzliche Rechenleistung benötigt.
</p><p>Für einen echten String-Deskriptor muss dem Text noch die Länge 
(in Bytes) sowie der Deskriptor-Typ (0x3 für Strings) vorangestellt 
werden. Das erledigt "EncodeDescriptors::USB20::string". Die 
vollständige Definition unserer String-Deskriptoren und die Auflistung 
in der Tabelle sieht dann z.B. so aus:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">strManufacturer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="p">(</span><span class="sa">u</span><span class="s">"ACME Corp."</span><span class="p">);</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">strProduct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="p">(</span><span class="sa">u</span><span class="s">"Fluxkompensator"</span><span class="p">);</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">strSerial</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="p">(</span><span class="sa">u</span><span class="s">"42-1337-47/11"</span><span class="p">);</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">langTable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">languageTable</span><span class="w"> </span><span class="p">(</span><span class="mh">0x0407</span><span class="w"> </span><span class="cm">/* German (Standard) */</span><span class="p">);</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">Descriptor</span><span class="w"> </span><span class="n">descriptors</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="w">									</span><span class="p">{</span><span class="w"> </span><span class="n">strManufacturer</span><span class="p">,</span><span class="w"> </span><span class="n">D_TYPE</span><span class="o">::</span><span class="n">STRING</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">									</span><span class="p">{</span><span class="w"> </span><span class="n">strProduct</span><span class="p">,</span><span class="w"> </span><span class="n">D_TYPE</span><span class="o">::</span><span class="n">STRING</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">									</span><span class="p">{</span><span class="w"> </span><span class="n">strSerial</span><span class="p">,</span><span class="w"> </span><span class="n">D_TYPE</span><span class="o">::</span><span class="n">STRING</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">}};</span><span class="w"></span>
</pre></div>
<p>Die String-Deskriptoren haben jetzt also die Indices 1,2,3. Diese 
können wir jetzt im Device Descriptor für die Werte iManufacturer, 
iProduct und iSerialNumber angeben. Dadurch erkennt Linux unser Gerät 
jetzt mit Namen:
</p>
<pre>[ 5089.189084] usb 2-2: new full-speed USB device number 16 using xhci_hcd
[ 5089.318259] usb 2-2: New USB device found, idVendor=dead, idProduct=beef
[ 5089.318263] usb 2-2: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[ 5089.318266] usb 2-2: Product: Fluxkompensator
[ 5089.318268] usb 2-2: Manufacturer: ACME Corp.
[ 5089.318270] usb 2-2: SerialNumber: 42-1337-47/11
[ 5089.319066] usb 2-2: can't set config #1, error -32
</pre>
<h3 class="mw-header"><a id="Restliche_Standard-Requests" href="#Restliche_Standard-Requests" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Restliche Standard-Requests</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=30" title="Abschnitt bearbeiten: Restliche Standard-Requests">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Das Betriebssystem akzeptiert unser Gerät immer noch nicht 
vollständig. Wir müssen noch auf einige weitere Standard-Requests 
reagieren. Wir fangen mit SET_CONFIGURATION an: Dieser Request schaltet 
zwischen den verschiedenen Konfigurationen ("Betriebsmodi") um. Da wir 
davon nur eine haben, muss hier nichts getan werden. Es gibt aber einen 
wichtigen "Nebeneffekt": Nach dem Umschalten müssen alle Bulk- und 
Interrupt-Endpoints auf "DATA0" gesetzt werden: Auf diesen Endpoints 
werden Datenblöcke abwechselnd mit den DATA0/DATA1 Befehlen übertragen, 
damit der Empfänger erkennen kann, ob ein Paket ein Korrekturversuch 
eines zuvor fehlerhaft übertragenen Pakets war, oder ob es das nächste 
Datenpaket ist. Auf Control Endpoints wird bei Setup-Paketen immer mit 
DATA0 begonnen, und Isochronous-Endpoints haben keine Fehlerkorrektur, 
weshalb dieser Mechanismus hier nicht genutzt wird. Nach 
SET_CONFIGURATION wird auf Bulk/Interrupt-Endpoints immer mit DATA0 
weiter gemacht. Die Umschaltung erfolgt über die EPnR-Register, indem 
die DTOG_RX und DTOG_TX-Bits auf 0 gesetzt werden (es handelt sich um 
Bits mit "Toggle"-Charakteristik, d.h. es muss der aktuelle Wert 
zurückgeschrieben werden um 0 zu erhalten). Dazu schreiben wir uns eine 
Funktion, welche bei SET_CONFIGURATION aufgerufen wird, alle 
EPnR-Register iteriert, ihren Typ auf Bulk/Interrupt prüft und die 
genannten Bits auf 0 setzt, sofern die entsprechende Richtung aktiviert 
ist:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">USBPhys::resetDataToggle</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint_fast8_t</span><span class="w"> </span><span class="n">iEP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iEP</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iEP</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EPnR</span><span class="w"> </span><span class="p">[</span><span class="n">iEP</span><span class="p">].</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="c1">// Prüfe Typ des Endpoints (Bulk/Interrupt)</span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">s</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">USB_EP_T_FIELD_Msk</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">USB_EP_BULK</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">USB_EP_T_FIELD_Msk</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">USB_EP_INTERRUPT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="c1">// Prüfe ob Senden/Empfangen aktiviert. Diese Information ließe sich auch über m_epBuffers</span>
<span class="w">			</span><span class="c1">// gewinnen, aber so ist es einfacher.</span>
<span class="w">			</span><span class="kt">bool</span><span class="w"> </span><span class="n">rx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">USB_EPRX_STAT</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">USB_EP_RX_DIS</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="kt">bool</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">USB_EPTX_STAT</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">USB_EP_TX_DIS</span><span class="p">;</span><span class="w"></span>
<span class="w">			</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rx</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">tx</span><span class="p">)</span><span class="w"></span>
<span class="w">				</span><span class="c1">// Setze beide Richtungen zurück</span>
<span class="w">				</span><span class="n">setEPnR</span><span class="w"> </span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">iEP</span><span class="p">),</span><span class="w"> </span><span class="n">USB_EP_DTOG_RX_Msk</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USB_EP_DTOG_TX_Msk</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rx</span><span class="p">)</span><span class="w"></span>
<span class="w">				</span><span class="c1">// Nur Empfangen zurücksetzen</span>
<span class="w">				</span><span class="n">setEPnR</span><span class="w"> </span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">iEP</span><span class="p">),</span><span class="w"> </span><span class="n">USB_EP_DTOG_RX_Msk</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">			</span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">)</span><span class="w"></span>
<span class="w">				</span><span class="c1">// Nur Senden zurücksetzen</span>
<span class="w">				</span><span class="n">setEPnR</span><span class="w"> </span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">iEP</span><span class="p">),</span><span class="w"> </span><span class="n">USB_EP_DTOG_TX_Msk</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Das war aber immer noch nicht alles: Es muss noch auf die Anfragen 
CLEAR_FEATURE, SET_FEATURE, GET_STATUS, GET_INTERFACE, SET_INTERFACE 
reagiert werden. Diese sind für Spezial-Funktionen, die für unser Gerät 
nicht relevant sind. Daher können wir hier jeweils eine "Dummy-Antwort" 
bzw. Fehler ("STALL") zurücksenden, die dem Host die Funktionalität 
vortäuschen. Auf die eher langweiligen Details wird hier nicht 
eingegangen und auf den <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/master/src/usb.cc#L565">Beispiel-Code</a> verwiesen.
</p>
<h4 class="mw-header"><a id="Vollständige_Enumeration" href="#Vollständige_Enumeration" title="Link to this section" class="mw-headline-headanchor"></a><span id="Vollst.C3.A4ndige_Enumeration"></span><span class="mw-headline">Vollständige Enumeration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=31" title="Abschnitt bearbeiten: Vollständige Enumeration">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Nach all der Vorarbeit haben wir endlich ein Gerät, das vollständig ohne Fehler erkannt wird und genau keine Funktion bietet:
</p>
<pre>[ 6607.039063] usb 2-2: new full-speed USB device number 20 using xhci_hcd
[ 6607.168365] usb 2-2: New USB device found, idVendor=dead, idProduct=beef
[ 6607.168369] usb 2-2: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[ 6607.168372] usb 2-2: Product: Fluxkompensator
[ 6607.168374] usb 2-2: Manufacturer: ACME Corp.
[ 6607.168375] usb 2-2: SerialNumber: 42-1337-47/11</pre>
<p>Das Hinzufügen sinnvoller Funktionalität auf Basis der erstellten Strukturen ist jetzt aber nicht mehr viel Aufwand.
</p>
<h3 class="mw-header"><a id="Eigene_Requests" href="#Eigene_Requests" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Eigene Requests</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=32" title="Abschnitt bearbeiten: Eigene Requests">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Die einfachste Möglichkeit, eigene Funktionen hinzuzufügen, ist das 
Reagieren auf Requests auf dem Default Control Endpoint 0, genau wie auf
 die Standard-Anfragen reagiert wird. Damit die eigenen Anfragen sich 
nicht mit den Standard-Anfragen überschneiden, sollten wir in 
bmRequestType die Bits 6 und 5 auf auf 1 bzw. 0 setzen, was einen 
Vendor-spezifischen Request markiert. Das höchste Bit sollte die 
Richtung angeben (0 = Host-&gt;Device, 1 = Device-&gt;Host). bRequest, 
wValue, wIndex und wLength können beliebig vergeben werden. Das nutzen 
wir, um 2 LED's auf dem Olimexino zu setzen und den aktuellen Zustand 
abfragen zu können:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bmRequestType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xC0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">bRequest</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// LED Status abfragen und 1-Byte-Datenpaket zusammensetzen</span>
<span class="w">	</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">LED1</span><span class="p">.</span><span class="n">getOutput</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">LED2</span><span class="p">.</span><span class="n">getOutput</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Absenden</span>
<span class="w">	</span><span class="n">dataInStage</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bmRequestType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x40</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">bRequest</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Bits aus wValue an die Pins übertragen</span>
<span class="w">	</span><span class="n">LED1</span><span class="p">.</span><span class="n">set</span><span class="w"> </span><span class="p">(</span><span class="n">wValue</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">LED2</span><span class="p">.</span><span class="n">set</span><span class="w"> </span><span class="p">(</span><span class="n">wValue</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">statusStage</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>LED1 und LED2 sind Instanzen der "Pin"-Klasse welche recht simpel ist
 und deren Funktionen genau das tun wonach sie aussehen. Details können 
im Beispielcode nachgesehen werden.
</p>
<h3 class="mw-header"><a id="Eigener_Bulk-Endpoint" href="#Eigener_Bulk-Endpoint" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Eigener Bulk-Endpoint</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=33" title="Abschnitt bearbeiten: Eigener Bulk-Endpoint">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Mit Requests auf dem Default Control Endpoint können wir die mögliche
 Datenrate von USB noch nicht ausnutzen. Daher nutzen wir den zuvor im 
Interface Descriptor angelegten Endpoint 1, um größere Datenmengen 
übertragen zu können. Als simplen Test implementieren wir ein "Loopback"
 bei dem wir alle empfangenen Datenpakete direkt wieder zurücksenden, 
nachdem wir jedes Byte einmal umgedreht haben. Dazu erstellen wir eine 
neue Klasse namens "MirrorEP" und leiten von "EPBuffer" ab. Davon legen 
wir eine globale Instanz an und übergeben einen Pointer darauf an die 
USBPhys-Instanz:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">class</span> <span class="nc">MirrorEP</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">EPBuffer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">		</span><span class="k">constexpr</span><span class="w"> </span><span class="n">MirrorEP</span><span class="w"> </span><span class="p">(</span><span class="n">UsbMem</span><span class="o">*</span><span class="w"> </span><span class="n">epBuffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">EPBuffer</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">EP_TYPE</span><span class="o">::</span><span class="n">BULK</span><span class="p">,</span><span class="w"> </span><span class="n">epBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="n">epBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">),</span><span class="w"> </span><span class="n">m_buffer</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">	</span><span class="k">protected</span><span class="o">:</span><span class="w"></span>
<span class="w">		</span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">onReceive</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">setup</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rxBytes</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">onTransmit</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">		</span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">onReset</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">		</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">m_buffer</span><span class="w"> </span><span class="p">[</span><span class="mi">64</span><span class="p">];</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">MirrorEP::onReset</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">EPBuffer</span><span class="o">::</span><span class="n">onReset</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Bereite Datenempfang vor</span>
<span class="w">	</span><span class="n">receivePacket</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">getRxBufLength</span><span class="p">(),</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="n">m_buffer</span><span class="p">)));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">MirrorEP::onReceive</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rxBytes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Frage empfangene Daten ab</span>
<span class="w">	</span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="n">m_buffer</span><span class="p">),</span><span class="w"> </span><span class="n">rxBytes</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">getReceivedData</span><span class="w"> </span><span class="p">(</span><span class="n">m_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Drehe jedes Byte um</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">m_buffer</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">__RBIT</span><span class="p">(</span><span class="n">m_buffer</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Sende Ergebnis zurück</span>
<span class="w">	</span><span class="n">transmitPacket</span><span class="w"> </span><span class="p">(</span><span class="n">m_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">MirrorEP::onTransmit</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Nach erfolgreichem Senden, mache erneut bereit zum Empfangen</span>
<span class="w">	</span><span class="n">receivePacket</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">getRxBufLength</span><span class="p">(),</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="n">m_buffer</span><span class="p">)));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">alignas</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">UsbAlloc</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="w"> </span><span class="n">EP0_BUF</span><span class="w">	</span><span class="n">USB_MEM</span><span class="p">;</span><span class="w"></span>
<span class="k">alignas</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">UsbAlloc</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="w"> </span><span class="n">EP1_BUF</span><span class="w">	</span><span class="n">USB_MEM</span><span class="p">;</span><span class="w"></span>
<span class="c1">/// Der Default Control Endpoint 0 ist Pflicht für alle USB-Geräte.</span>
<span class="k">static</span><span class="w"> </span><span class="n">DefaultControlEP</span><span class="w"> </span><span class="nf">controlEP</span><span class="w"> </span><span class="p">(</span><span class="n">usbPhys</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">EP0_BUF</span><span class="p">.</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">EP0_BUF</span><span class="p">.</span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="c1">/// Lege Endpoint zum Umdrehen der Daten an</span>
<span class="n">MirrorEP</span><span class="w"> </span><span class="nf">mirrorEP</span><span class="w"> </span><span class="p">(</span><span class="n">EP1_BUF</span><span class="p">.</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">EP1_BUF</span><span class="p">.</span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="c1">/// Zentrale Instanz für USB-Zugriff. Übergebe 2 Endpoints.</span>
<span class="n">USBPhys</span><span class="w"> </span><span class="nf">usbPhys</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">EPBuffer</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">controlEP</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mirrorEP</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="p">}});</span><span class="w"></span>
</pre></div>
<p>Dies ist relativ viel Code für so eine einfache Operation, aber die 
Nutzung der abstrakten EPBuffer-Klasse ermöglicht die Implementation 
unseres Loopbacks ohne die Low-Level USB-Routinen anpassen zu müssen. 
Die so hinzugefügte Funktionalität ändert das Verhalten des Hosts nicht -
 wir brauchen jetzt eine Gegenstelle, welche die entsprechenden Daten 
sendet um die Funktionen zu testen.
</p>
<h2 class="mw-header"><a id="Eigene_Anwendung_für_PC-Seite" href="#Eigene_Anwendung_für_PC-Seite" title="Link to this section" class="mw-headline-headanchor"></a><span id="Eigene_Anwendung_f.C3.BCr_PC-Seite"></span><span class="mw-headline">Eigene Anwendung für PC-Seite</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=34" title="Abschnitt bearbeiten: Eigene Anwendung für PC-Seite">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Wie bereits erwähnt, wollen wir die PC-Seite über libusb 
implementieren, was uns ermöglicht, aus einer gewöhnlichen Anwendung 
direkt auf das Gerät zuzugreifen, ohne selbst einen Treiber 
implementieren zu müssen. Dies dürfte die einfachste Möglichkeit sein, 
mit eigenen USB-Geräten zu kommunizieren. Das Beispielprogramm dafür ist
 ebenfalls auf <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/usbclient">GitHub</a>
 zu finden. Dies ist mit CMake implementiert und kann für Linux und 
Windows kompiliert werden. Der eigentliche Code ist plattformunabhängig -
 ein #include "libusb.h" reicht um libusb einzubinden. Es ist 
empfehlenswert, zunächst das Beispielprogramm wie auf der GitHub-Seite 
beschrieben in Betrieb zu nehmen, bevor mit einem eigenen Projekt 
begonnen wird. Dort sind auch fertig kompilierte Programmdateien 
verfügbar.
</p>
<h3 class="mw-header"><a id="Einbinden_von_LibUsb" href="#Einbinden_von_LibUsb" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Einbinden von LibUsb</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=35" title="Abschnitt bearbeiten: Einbinden von LibUsb">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Im Folgenden wird kurz beschrieben, wie libusb in eigene Projekte integriert werden kann.
</p>
<h4 class="mw-header"><a id="Linux" href="#Linux" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Linux</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=36" title="Abschnitt bearbeiten: Linux">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Zunächst müssen die Header-und Binärdateien von libusb installiert werden. Unter Ubuntu geschieht das über das Paket <a rel="nofollow" class="external text" href="https://packages.ubuntu.com/xenial/libusb-1.0-0-dev">libusb-1.0-0-dev</a>. Eigener Sourcecode auf Basis von libusb kann dann so kompiliert und gelinkt werden:
</p>
<div class="mw-highlight mw-highlight-lang-shell mw-content-ltr" dir="ltr"><pre><span></span>$ g++ main.cc -c -o main.o <span class="sb">`</span>pkg-config --cflags libusb-1.0<span class="sb">`</span>
$ g++ main.o -o usbclient <span class="sb">`</span>pkg-config --libs libusb-1.0<span class="sb">`</span>
</pre></div>
<p>Das Beispielprojekt generiert über CMake ein Makefile, welches genau 
so funktioniert. Wenn man das so erstellte Programm  als "root"-User 
ausführt, funktioniert es direkt.
</p>
<h4 class="mw-header"><a id="Windows_/_Visual_Studio" href="#Windows_/_Visual_Studio" title="Link to this section" class="mw-headline-headanchor"></a><span id="Windows_.2F_Visual_Studio"></span><span class="mw-headline">Windows / Visual Studio</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=37" title="Abschnitt bearbeiten: Windows / Visual Studio">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Für Windows gibt es auf der <a rel="nofollow" class="external text" href="http://libusb.info/">libusb-Website</a>
 fertig kompilierte Bibliotheken-Dateien zum Herunterladen. Diese können
 in eigene Visual Studio-Projekte eingebunden werden. Die Bibliothek 
liegt in Form von DLL-Dateien vor, welche dann mit der eigenen Anwendung
 ausgeliefert werden müssen. Alternativ kann auch die "statische" 
Version genutzt werden, deren Inhalt dann mit in die erstellte 
.exe-Datei eingebunden wird, sodass diese ohne zusätzliche Dateien 
funktioniert. Da die libusb unter der LGPL-Lizenz steht, ist diese 
Option nur für Open Source-Programme erlaubt. Die statischen 
Bibliotheksdateien funktionieren auch nur mit älteren Visual 
Studio-Versionen. Es ist aber relativ einfach, mit einer aktuellen 
VS-Version libusb selbst zu kompilieren, um statische Bibliotheken zu 
erhalten, die dann (nur) mit dieser VS-Version funktionieren. Im 
"usbclient"-Projekt sind solche vorkompilierte Bibliotheksdateien für 
Visual Studio 15 2017 mitgeliefert, für 32/64-Bit als statische und 
dynamische (DLL) Bibliothek. Legt man ein eigenes VS-Projekt an, muss 
man die Pfade zur gewünschten Variante der Bibliothek sowie zu den 
Header-Dateien einstellen. Im Beispielprojekt ist das bereits erledigt.
</p>
<h3 class="mw-header"><a id="Konfiguration_der_PC-Seite" href="#Konfiguration_der_PC-Seite" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Konfiguration der PC-Seite</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=38" title="Abschnitt bearbeiten: Konfiguration der PC-Seite">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4 class="mw-header"><a id="Windows:_Laden_von_WinUSB" href="#Windows:_Laden_von_WinUSB" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Windows: Laden von WinUSB</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=39" title="Abschnitt bearbeiten: Windows: Laden von WinUSB">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="https://www.mikrocontroller.net/articles/Datei:WinUSB_Device.png" class="image"><img alt="" src="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/300px-WinUSB_Device.webp" decoding="async" class="thumbimage" srcset="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/450px-WinUSB_Device.webp 1.5x, USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/600px-WinUSB_Device.webp 2x" width="300" height="220"></a>  <div class="thumbcaption"><div class="magnify"><a href="https://www.mikrocontroller.net/articles/Datei:WinUSB_Device.png" class="internal" title="vergrößern"></a></div>Anzeige des WinUSB-Device im Gerätemanager</div></div></div><p>Unter
 Windows können libusb-Programme nicht ohne Weiteres direkt auf die 
Hardware zugreifen. Dazu ist es erst nötig, einen Treiber für das Gerät 
zu installieren/laden, welcher libusb den Zugriff ermöglicht. Es gibt 
verschiedene Projekte, die derartige Treiber zur Verfügung stellen, auf 
die mit libusb aus dem eigenen Programm zugegriffen werden kann:
</p><ul><li><a rel="nofollow" class="external text" href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff540196(v=vs.85).aspx">Microsoft WinUSB</a></li>
<li><a rel="nofollow" class="external text" href="http://libusbk.sourceforge.net/UsbK3/index.html">libusbK</a></li>
<li><a rel="nofollow" class="external text" href="https://github.com/daynix/UsbDk">usbdk</a></li>
<li><a rel="nofollow" class="external text" href="https://sourceforge.net/p/libusb-win32/wiki/Home/">libusb-win32</a> (veraltet)</li></ul>
<p>Im Folgenden wird nur auf WinUSB eingegangen. Dies hat den großen 
Vorteil, dass es bereits auf aktuellen Windows-Versionen vorinstalliert 
ist. Man muss Windows "nur" noch dazu bringen, den WinUSB-Treiber für 
das eigene Gerät zu laden. Dies kann man manuell im Geräte-Manager tun 
(umständlich), oder komfortabler über das Programm <a rel="nofollow" class="external text" href="http://zadig.akeo.ie/">Zadig</a>,
 welches übrigens auch die anderen aufgelisteten Treiber unterstützt. 
Leider sind dort nicht immer die aktuellen Versionen mitgeliefert. Die 
"traditionelle" Variante besteht darin, eine eigene .inf und .cat -Datei
 anzulegen, welche Windows anweist, für ein bestimmtes Gerät den 
gewünschten Treiber zu laden. Allerdings muss letztere Datei korrekt 
signiert sein, und die Installation von nicht/selbst-signierten Dateien 
wird mir neueren Windows-Versionen zunehmend umständlicher und ist unter
 Windows 10 gänzlich unpraktikabel.
</p><p>Seit Windows 8 gibt es noch eine andere Möglichkeit: Man kann das
 Gerät durch Hinzufügen spezieller von Microsoft definierter 
Deskriptoren als sogenanntes <a rel="nofollow" class="external text" href="https://msdn.microsoft.com/en-us/library/hh450799.aspx">WinUSB Device</a>
 markieren. Windows lädt dafür vollautomatisch ohne jede 
Nutzer-Interaktion den WinUSB-Treiber, und man kann sofort die 
libusb-Anwendung nutzen. Unter anderen Betriebssystemen hat das keine 
Auswirkung, hier funktioniert das Gerät wie zuvor. <a rel="nofollow" class="external text" href="https://github.com/pbatard/libwdi/wiki/WCID-Devices">Hier</a>
 findet sich eine gute Erläuterung der benötigten Deskriptoren. Daher 
wird hier nur kurz gezeigt, wie diese Daten anzulegen sind.
</p><p>Es wird ein zusätzlicher String-Deskriptor benötigt sowie der 
sogenannte Compat Id Descriptor, für den in der usb_desc_helper.hh eine 
Funktion vorbereitet ist:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">strOsStringDesc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="sa">u</span><span class="s">"MSFT100</span><span class="se">\u0003</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">compatIdDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">MS_OS_Desc</span><span class="o">::</span><span class="n">compatId</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">			</span><span class="mh">0x100</span><span class="p">,</span><span class="w">					</span><span class="c1">// bcdVersion</span>
<span class="w">			</span><span class="mi">4</span><span class="p">,</span><span class="w">						</span><span class="c1">// wIndex</span>
<span class="w">			</span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">MS_OS_Desc</span><span class="o">::</span><span class="n">compatIdFunction</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">				</span><span class="mi">0</span><span class="p">,</span><span class="w">									</span><span class="c1">// bFirstInterfaceNumber</span>
<span class="w">				</span><span class="n">Util</span><span class="o">::</span><span class="n">encodeString</span><span class="w"> </span><span class="p">(</span><span class="s">"WINUSB</span><span class="se">\0\0</span><span class="s">"</span><span class="p">),</span><span class="w">	</span><span class="c1">// compatibleID</span>
<span class="w">				</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Util</span><span class="o">::</span><span class="n">EncChar</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">				</span><span class="c1">// subCompatibleID</span>
<span class="w">			</span><span class="p">)</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">Descriptor</span><span class="w"> </span><span class="n">descriptors</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">[...]</span><span class="w"></span>
<span class="w">									</span><span class="p">{</span><span class="w"> </span><span class="n">strOsStringDesc</span><span class="p">,</span><span class="w"> </span><span class="n">D_TYPE</span><span class="o">::</span><span class="n">STRING</span><span class="p">,</span><span class="w"> </span><span class="mh">0xEE</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">									</span><span class="p">{</span><span class="w"> </span><span class="n">compatIdDescriptor</span><span class="p">,</span><span class="w"> </span><span class="n">D_TYPE</span><span class="o">::</span><span class="n">OS_DESCRIPTOR</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">DefaultControlEP::onSetupStage</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="p">[...]</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w">	</span><span class="c1">// Eine Standard-USB-Anfrage eines Deskriptors</span>
<span class="w">			</span><span class="p">(</span><span class="n">bmRequestType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x80</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">bRequest</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ST_REQ</span><span class="o">::</span><span class="n">GET_DESCRIPTOR</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="c1">// Oder eine Microsoft-spezifische Abfrage eines OS String Deskriptors</span>
<span class="w">	</span><span class="o">||</span><span class="w">		</span><span class="p">(</span><span class="n">bmRequestType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xC0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">bRequest</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ST_REQ</span><span class="o">::</span><span class="n">GET_OS_STRING_DESC</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="c1">// Bei Standard-Anfragen ist der Typ des Deskriptors vorgegeben, ansonsten immer den OS String Deskriptor nehmen</span>
<span class="w">		</span><span class="n">D_TYPE</span><span class="w"> </span><span class="n">descType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bmRequestType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xC0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">D_TYPE</span><span class="o">::</span><span class="nl">OS_DESCRIPTOR</span> <span class="p">:</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">D_TYPE</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">wValue</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="c1">// Es gibt nur 1 OS String Deskriptor; bei anderen nutze den gewünschten Index</span>
<span class="w">		</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">descIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bmRequestType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xC0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">wValue</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">);</span><span class="w"></span>

<span class="w">		</span><span class="c1">// Durchsuche Deskriptor-Tabelle</span>
<span class="w">		</span><span class="k">const</span><span class="w"> </span><span class="n">Descriptor</span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getUsbDescriptor</span><span class="w"> </span><span class="p">(</span><span class="n">descType</span><span class="p">,</span><span class="w"> </span><span class="n">descIndex</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">[...]</span><span class="w"></span>
</pre></div>
<p>Der String-Deskriptor wird über die ID 0xEE abgefragt. Windows sendet
 dann einen Befehl mit bmRequestType = 0xC0 und mit bRequest gleich der 
"Vendor"-Nummer, welche im String-Deskriptor definiert wurde. Im 
Beispiel ist sie "3". Auf diesen Request muss das Programm mit dem 
Compat Id Descriptor antworten. Im Beispielprogramm wird das erreicht 
indem diese Anfrage genau wie GET_DESCRIPTOR behandelt wird, und der 
Deskriptor in das globale "descriptors"-Array einsortiert wird unter 
Nutzung eines eigenen Deskriptor-Typs.
</p>
<h4 class="mw-header"><a id="Linux:_Setzen_der_udev-Regeln" href="#Linux:_Setzen_der_udev-Regeln" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Linux: Setzen der udev-Regeln</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=40" title="Abschnitt bearbeiten: Linux: Setzen der udev-Regeln">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Unter Linux haben normale User erstmal keine Berechtigung um auf 
beliebige USB-Geräte zuzugreifen - das würde im Falle von Datenträgern 
auch die komplette Datei-Rechteverwaltung außer Gefecht setzen. Wir 
können manuell die richtige Datei unter /dev/bus/usb ausfindig machen 
und die Berechtigungen anpassen, was aber nach jeder Verbindung des 
Geräts passieren muss und ziemlich lästig ist. Stattdessen kann man 
"udev", dem Programm welches die Gerätedateien unter /dev überhaupt erst
 anlegt, mitteilen wie es die Berechtigung unseres eigenes Geräts 
anpassen soll. Dazu legen wir z.B. unter 
/etc/udev/rules.d/99-deadbeef.rules (Name an Gerätetyp anpassen) eine 
Textdatei mit folgendem Inhalt an:
</p>
<pre>SUBSYSTEM=="usb", ATTR{idVendor}=="dead", ATTR{idProduct}=="beef", MODE="0666"</pre>
<p>Die beiden Zahlen müssen dabei der VID/PID des Geräts entsprechen. 
Über "0666" geben wir oktal die gewünschte Berechtigung an, ähnlich wie 
bei "chmod". 0666 bedeutet dabei, dass jeder User Schreib-und 
Lesezugriff erhält. Alternativ könnte die Gerätedatei auch nur einer 
Benutzergruppe zugänglich gemacht werden, sodass nur bestimmte User - 
die in der Gruppe - Zugriff erhalten. Siehe dazu die <a rel="nofollow" class="external text" href="https://www.freedesktop.org/software/systemd/man/udev.html">Dokumentation</a> für die udev-Regeldateien. Die Änderung wird erst nach einem Neustart wirksam, oder nach Ausführung dieses Befehls:
</p>
<pre>sudo udevadm control -R</pre>
<p>Die Datei kann dem Benutzer zusammen mit dem Programm ausgeliefert werden, und z.B. mit in das .deb Paket verpackt werden.
</p>
<h3 class="mw-header"><a id="Das_libusb-API" href="#Das_libusb-API" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Das libusb-API</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=41" title="Abschnitt bearbeiten: Das libusb-API">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Nachdem jetzt alles vorbereitet ist, können wir ein eigenes Programm 
mit libusb für den Zugriff auf unser USB-Gerät schreiben. Dazu werden im
 Folgenden kurz die Grundlagen von libusb gezeigt.
</p>
<h4 class="mw-header"><a id="Ressourcen-Verwaltung" href="#Ressourcen-Verwaltung" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Ressourcen-Verwaltung</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=42" title="Abschnitt bearbeiten: Ressourcen-Verwaltung">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>libusb hat ein <a rel="nofollow" class="external text" href="http://libusb.sourceforge.net/api-1.0/modules.html">C-API</a>,
 was die Fehlerbehandlung etwas lästig macht. Wir wollen nicht gleich 
einen ganzen C++-Wrapper dafür implementieren, aber die 
Ressourcenverwaltung und Fehlerbehandlung um "RAII" und Exceptions 
aufrüsten, um den Code übersichtlich zu halten. Viele der Funktionen von
 libusb geben einen Integer-Typ zurück (aber nicht alle den gleichen), 
bei dem ein negativer Wert einen Fehler anzeigt. Daher schreiben wir uns
 eine Funktion "lu_err", welcher dieser Rückgabewert sowie eine 
Fehlermeldung als String übergeben wird. Ist der Wert &gt;= 0, wird er 
einfach direkt zurückgegeben. Ist er negativ, wird eine Exception mit 
der Fehlermeldung ausgelöst, wobei auch die textuelle Beschreibung des 
Fehlers von libusb abgefragt wird:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Ret</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">Ret</span><span class="w"> </span><span class="n">lu_err</span><span class="w"> </span><span class="p">(</span><span class="n">Ret</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">errmsg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="c1">// Frage Fehlerbeschreibung der Libusb ab und baue Fehlermeldung zusammen</span>
<span class="w">		</span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="w"> </span><span class="p">(</span><span class="n">errmsg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">libusb_error_name</span><span class="w"> </span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">" - "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">libusb_strerror</span><span class="w"> </span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">libusb_error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="p">)));</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Beim Auslösen einer Exception wird bekanntlich zum im Aufrufstack 
nächsten "catch"-Block gesprungen. Wenn wir zwischenzeitlich Ressourcen 
angefragt haben (z.B. Device-Handler), werden diese dann nicht mehr 
freigegeben. Es werden aber die Destruktoren aller Objekte aufgerufen, 
welche in den nun verlassenen Scopes (Funktionen, if-Blöcke, Schleifen) 
bis dahin angelegt wurden. Dies nutzen wir mithilfe der <a rel="nofollow" class="external text" href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>-Klasse
 aus, indem wir Pointer auf automatisch zu löschende Ressourcen an diese
 übergeben und einen eigenen "Deleter" angeben, um die entsprechende 
libusb-Funktion zur Freigabe aufzurufen. Am Beispiel des libusb_context,
 der für die ganze Nutzungsdauer der libusb existieren muss, sieht das 
dann so aus:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">/// Ein Dummy-Struct zur Freigabe des libusb context. Kann als "Deleter" in std::unique_ptr genutzt werden.</span>
<span class="k">struct</span> <span class="nc">ExitLibusb</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">void</span><span class="w"> </span><span class="nf">operator</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="n">libusb_context</span><span class="o">*</span><span class="w"> </span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">libusb_exit</span><span class="w"> </span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="c1">/// Ein libusb_context welcher in diesem unique_ptr verpackt wird, wird automatisch korrekt freigegeben.</span>
<span class="k">using</span><span class="w"> </span><span class="n">CtxPtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">libusb_context</span><span class="p">,</span><span class="w"> </span><span class="n">ExitLibusb</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Initialisiere libusb</span>
<span class="n">libusb_context</span><span class="o">*</span><span class="w"> </span><span class="n">ctx</span><span class="p">;</span><span class="w"></span>
<span class="n">lu_err</span><span class="w"> </span><span class="p">(</span><span class="n">libusb_init</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">),</span><span class="w"> </span><span class="s">"Initialisierung von libusb fehlgeschlagen: "</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Verpacke libusb Kontext in unique_ptr für automatische Freigabe</span>
<span class="n">CtxPtr</span><span class="w"> </span><span class="nf">ctxPtr</span><span class="w"> </span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Solange ctxPtr existiert, kann der Kontext genutzt werden. Wenn die 
diesen Code umschließende Funktion verlassen wird, wird der Kontext 
automatisch freigegeben. Analog verfahren wir mit Device-Listen und 
Device-Handles.
</p>
<h4 class="mw-header"><a id="Gerät_finden" href="#Gerät_finden" title="Link to this section" class="mw-headline-headanchor"></a><span id="Ger.C3.A4t_finden"></span><span class="mw-headline">Gerät finden</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=43" title="Abschnitt bearbeiten: Gerät finden">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Nachdem wir so den Kontext initialisiert haben, müssen wir unser 
angeschlossenes Gerät ausfindig machen. Hierbei macht sich ein Vorteil 
von USB bemerkbar: Das richtige Gerät lässt sich über die VID/PID 
identifizieren, der Benutzer muss keine Port-Nummer angeben. Über die 
Funktion libusb_get_device_list fragen wir eine Liste aller 
angeschlossener Geräte ab. Hier nutzen wir wieder std::unique_ptr, um 
die Liste beim Verlassen wieder freizugeben. Mit 
libusb_get_device_descriptor können wir dann die Informationen jedes 
Geräts abfragen - den Device Descriptor, den wir selbst zuvor angelegt 
haben. Durch Vergleich der darin enthaltenen VID/PID prüfen wir, ob es 
sich um das gesuchte Gerät handelt. Das könnte so aussehen:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Die Liste der angeschlossenen Geräte</span>
<span class="n">libusb_device</span><span class="w"> </span><span class="o">**</span><span class="n">list_raw</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Frage Liste ab, libusb_get_device_list allokiert Speicher</span>
<span class="kt">ssize_t</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lu_err</span><span class="p">(</span><span class="n">libusb_get_device_list</span><span class="w"> </span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">list_raw</span><span class="p">),</span><span class="w"> </span><span class="s">"Liste angeschlossener Geräte konnte nicht abgefragt werden: "</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Verpacke Liste in unique_ptr für automatische Freigabe</span>
<span class="n">DevListPtr</span><span class="w"> </span><span class="nf">list</span><span class="w"> </span><span class="p">(</span><span class="n">list_raw</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Iteriere gefundene Geräte</span>
<span class="kt">ssize_t</span><span class="w"> </span><span class="n">iFound</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Angeschlossene Geräte:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cnt</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Das Gerät</span>
<span class="w">	</span><span class="n">libusb_device</span><span class="w"> </span><span class="o">*</span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span><span class="n">libusb_device_descriptor</span><span class="w"> </span><span class="n">deviceDescriptor</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Frage Device Descriptor ab</span>
<span class="w">	</span><span class="n">lu_err</span><span class="w"> </span><span class="p">(</span><span class="n">libusb_get_device_descriptor</span><span class="w"> </span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">deviceDescriptor</span><span class="p">),</span><span class="w"> </span><span class="s">"Konnte Geräte-Deskriptor nicht abfragen: "</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="c1">// Prüfe auf gewünschte VID+PID</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iFound</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">deviceDescriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xDEAD</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">deviceDescriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xBEEF</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="c1">// Merke Index</span>
<span class="w">		</span><span class="n">iFound</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iFound</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="w"> </span><span class="p">(</span><span class="s">"Kein passendes USB-Gerät gefunden."</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h4 class="mw-header"><a id="Gerät_öffnen" href="#Gerät_öffnen" title="Link to this section" class="mw-headline-headanchor"></a><span id="Ger.C3.A4t_.C3.B6ffnen"></span><span class="mw-headline">Gerät öffnen</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=44" title="Abschnitt bearbeiten: Gerät öffnen">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Wenn wir ein passendes libusb_device gefunden haben, müssen wir es öffnen und das erste Interface in Anspruch nehmen:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Öffne Device</span>
<span class="n">libusb_device_handle</span><span class="w"> </span><span class="o">*</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="n">lu_err</span><span class="w"> </span><span class="p">(</span><span class="n">libusb_open</span><span class="w"> </span><span class="p">(</span><span class="n">list</span><span class="w"> </span><span class="p">[</span><span class="n">iFound</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handle</span><span class="p">),</span><span class="w"> </span><span class="s">"Konnte Gerät nicht öffnen: "</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Verpacke Handle in unique_ptr für automatische Freigabe</span>
<span class="n">DevPtr</span><span class="w"> </span><span class="nf">devPtr</span><span class="w"> </span><span class="p">(</span><span class="n">handle</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Beanspruche das Interface für diese Anwendung (sendet nichts auf dem Bus)</span>
<span class="n">lu_err</span><span class="w"> </span><span class="p">(</span><span class="n">libusb_claim_interface</span><span class="w"> </span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="s">"Konnte Interface nicht öffnen: "</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h4 class="mw-header"><a id="Abfrage_der_String-Deskriptoren" href="#Abfrage_der_String-Deskriptoren" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Abfrage der String-Deskriptoren</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=45" title="Abschnitt bearbeiten: Abfrage der String-Deskriptoren">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Als nächstes wollen wir die String-Deskriptoren anzeigen. Dazu nutzen
 wir libusb_get_string_descriptor_ascii, um die Strings nach ASCII zu 
konvertieren, denn die plattformübergreifende Konsolen-Ausgabe von 
UTF-16-Strings ist kompliziert. Bei der Entwicklung von 
GUI-Applikationen mit z.B. dem Gtk+ können wir den UTF-16-String 
abfragen, nach UTF-8 konvertieren und direkt anzeigen. Für die Funktion 
brauchen wir einen eigenen Puffer und den Index des String-Deskriptors, 
den wir dem Device-Deskriptor entnehmen:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// libusb erwartet einen String-Puffer. 256 Bytes ist die Maximal-Länge bei String-Deskriptoren, und wir brauchen noch ein Zeichen mehr zum Terminieren</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">strBuffer</span><span class="w"> </span><span class="p">[</span><span class="mi">257</span><span class="p">];</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">foundDeviceDescriptor</span><span class="p">.</span><span class="n">iManufacturer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Frage Deskriptor ab</span>
<span class="w">	</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lu_err</span><span class="w"> </span><span class="p">(</span><span class="n">libusb_get_string_descriptor_ascii</span><span class="w"> </span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">foundDeviceDescriptor</span><span class="p">.</span><span class="n">iManufacturer</span><span class="p">,</span><span class="w"> </span><span class="n">strBuffer</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="n">strBuffer</span><span class="p">)</span><span class="mi">-1</span><span class="p">),</span><span class="w"> </span><span class="s">"Konnte Hersteller-String nicht abfragen: "</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="c1">// Setze terminierendes 0-Byte</span>
<span class="w">	</span><span class="n">strBuffer</span><span class="w"> </span><span class="p">[</span><span class="n">len</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Manufacturer: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">strBuffer</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Analog verfahren wir mit dem Product- und dem Serial-String. 
Letzterer kann genutzt werden, um verschiedene Exemplare des gleichen 
Gerätetyps zu unterscheiden, und dem Nutzer eines eigenen Programms die 
Möglichkeit zu geben, ein bestimmtes Gerät auszuwählen, wenn mehrere 
davon am PC angeschlossen sind. Dies wird z.B. in der J-Link-Software so
 gemacht.
</p>
<h4 class="mw-header"><a id="Control-Transfers" href="#Control-Transfers" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Control-Transfers</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=46" title="Abschnitt bearbeiten: Control-Transfers">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Jetzt wollen wir unser Gerät etwas sinnvolles tun lassen, und die 
LED's vom PC aus steuern. Dazu müssen wir einen Control-Transfer mit der
 selbst definierten Anfrage senden. Dazu kodieren wir den Wunschzustand 
in einem Integer, welchen wir in wValue an das Gerät senden werden, 
indem wir libusb_control_transfer aufrufen:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Prüfe Kommandozeilenargumente</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">LED1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"1"</span><span class="p">;</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">LED2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"1"</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Baue Paket zusammen</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">ledData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">{</span><span class="w"> </span><span class="n">LED1</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">{</span><span class="w"> </span><span class="n">LED2</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="c1">// Sende Anfrage, nutze Paket für wValue</span>
<span class="n">lu_err</span><span class="w"> </span><span class="p">(</span><span class="n">libusb_control_transfer</span><span class="w"> </span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="mh">0x40</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ledData</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="s">"Konnte LED-Zustand nicht setzen: "</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Die Gegenrichtung zum Abfragen des aktuellen Zustands geht ebenfalls über libusb_control_transfer:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Frage aktuellen Zustand ab, empfange dazu ein 1-Byte-Paket</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">ledData</span><span class="p">;</span><span class="w"></span>
<span class="n">lu_err</span><span class="w"> </span><span class="p">(</span><span class="n">libusb_control_transfer</span><span class="w"> </span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="mh">0xC0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ledData</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="s">"Konnte LED-Zustand nicht abfragen: "</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Extrahiere Daten aus Paket und gebe sie aus</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"LED1: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="n">ledData</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"LED2: "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{(</span><span class="n">ledData</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Zum Schluss wollen wir noch die Übertragung größerer Datenmengen 
testen, indem wir ein aus zufälligen Bytes bestehendes Datenpaket an den
 Bulk Endpoint 1 senden, die Antwort empfangen, und prüfen ob jedes Byte
 wie gewünscht gedreht wurde. Die Datenübertragung läuft dabei über 
libusb_control_transfer:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Sende Datenblock</span>
<span class="kt">int</span><span class="w"> </span><span class="n">sent</span><span class="p">;</span><span class="w"></span>
<span class="n">lu_err</span><span class="w"> </span><span class="p">(</span><span class="n">libusb_bulk_transfer</span><span class="w"> </span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">txBuffer</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="n">txBuffer</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sent</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="s">"OUT Transfer fehlgeschlagen: "</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Empfange antwort</span>
<span class="n">lu_err</span><span class="w"> </span><span class="p">(</span><span class="n">libusb_bulk_transfer</span><span class="w"> </span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="mh">0x81</span><span class="p">,</span><span class="w"> </span><span class="n">rxBuffer</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="n">rxBuffer</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sent</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="s">"IN Transfer fehlgeschlagen: "</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Zu beachten ist, dass wir den Endpoint 1 als "half-duplex" 
implementiert haben, d.h. dass erst wieder Daten vom Gerät empfangen 
werden können, nachdem wir das zurückgesendete Paket vom PC aus 
abgefragt haben. Ein wiederholtes Senden von Daten an das Gerät ohne 
zwischenzeitliches Abfragen der Antwort bewirkt eine Blockade der 
Kommunikation.
</p><p>Ein vollständiger Lauf des Beispielprogramms sieht dann (gekürzt) etwa so aus:
</p>
<pre>$ ./usbclient 0 1
Angeschlossene Geräte:
2:8:5 04f2:b336
2:5:9 04ca:300b
2:2:10 dead:beef
2:4:6 046d:0a1f
[...]
Manufacturer: ACME Corp.
Product: Fluxkompensator
Serial: 42-1337-47/11
LED1: 1
LED2: 0
Sende Daten    &nbsp;: de, c8, 1d, a0, 7b, 33, 65, f0 [...]
Empfangene Daten: 7b, 13, b8, 05, de, cc, a6, 0f [...]
Daten stimmen überein: true</pre>
<p>Das war's! Wir haben ein eigenes simples USB-Gerät implementiert und 
vom PC aus plattformunabhängig angesteuert. Auf dieser Basis können wir 
jetzt kompliziertere Geräte mit sinnvollerer Funktion entwickeln.
</p>
<h2 class="mw-header"><a id="Vollständige_Umsetzung_von_Control_Endpoints" href="#Vollständige_Umsetzung_von_Control_Endpoints" title="Link to this section" class="mw-headline-headanchor"></a><span id="Vollst.C3.A4ndige_Umsetzung_von_Control_Endpoints"></span><span class="mw-headline">Vollständige Umsetzung von Control Endpoints</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=47" title="Abschnitt bearbeiten: Vollständige Umsetzung von Control Endpoints">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Unser USB-Hello-World enthält nur eine rudimentäre Umsetzung des 
Protokolls für Control Endpoints. Damit können außer dem Setup-Block 
keine Daten vom Host empfangen werden, und es können nur Daten gesendet 
werden, die in ein Paket passen, was maximal 64 Byte groß sein darf. 
Insbesondere für die Standard-Geräteklassen werden aber oft wesentlich 
längere Deskriptoren benötigt, die wir so nicht senden können. Daher 
soll die Unterstützung jetzt ausgebaut werden, indem die 
ControlEP-Klasse entsprechend erweitert wird. Da wir von Anfang an das 
Protokoll in dieser Klasse gekapselt haben, müssen wir keine anderen 
Programmteile modifizieren.
</p><p>In der Klasse implementieren wir jetzt einen endlichen Automaten,
 der sich merkt, an welcher Stelle im Protokoll er gerade ist. Dazu 
definieren wir ein enum, was die einzelnen Zustände angibt:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="k">enum</span> <span class="k">class</span><span class="w"> </span><span class="nc">CTRL_STATE</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">SETUP</span><span class="p">,</span><span class="w"> </span><span class="n">DATA_OUT</span><span class="p">,</span><span class="w"> </span><span class="n">DATA_IN</span><span class="p">,</span><span class="w"> </span><span class="n">DATA_IN_LAST</span><span class="p">,</span><span class="w"> </span><span class="n">STATUS_IN</span><span class="p">,</span><span class="w"> </span><span class="n">STATUS_OUT</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="https://www.mikrocontroller.net/articles/Datei:USB_ControlEP_FSM.svg" class="image"><img alt="" src="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/300px-USB_ControlEP_FSM.webp" decoding="async" class="thumbimage" srcset="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/450px-USB_ControlEP_FSM.webp 1.5x, USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/600px-USB_ControlEP_FSM.webp 2x" width="300" height="188"></a>  <div class="thumbcaption"><div class="magnify"><a href="https://www.mikrocontroller.net/articles/Datei:USB_ControlEP_FSM.svg" class="internal" title="vergrößern"></a></div>Zustandsdiagramm für Control Transfers</div></div></div><p>Die Bedeutung der einzelnen Zustände ist:
</p><ul><li>Bei Anfangszustand <b>SETUP</b> wird auf den Empfang eines 
Setup-Pakets gewartet (Setup-Stage). Von hier wird je nach Anfrage 
entweder nach DATA_OUT, DATA_IN, DATA_IN_LAST oder STATUS_OUT 
gewechselt, oder im Fehlerfall in SETUP verblieben.</li>
<li>Im Zustand <b>DATA_OUT</b> wird auf den Empfang eines Datenpakets 
der Data-Stage gewartet. Wenn der Host ein Paket sendet, dessen Länge 
geringer als die maximale Paketgröße (bMaxPacketSize0 im Device 
Descriptor) ist oder ein leeres Paket (nötig wenn die Gesamt-Länge ein 
Vielfaches der max. Paketgröße ist) bedeutet dies, dass keine weiteren 
Daten mehr vorliegen. Dann wird von hier nach STATUS_OUT gewechselt. Im 
Fehlerfall geht es direkt zurück nach SETUP.</li>
<li>Im Zustand <b>DATA_IN</b> wird auf das vollständige Absenden eines 
Datenpakets in der Data-Stage gewartet. Wenn das Ende des Datenblocks 
erreicht wird, wird dies signalisiert, indem ein unvollständiges oder 
leeres Datenpaket (analog zum Empfang) gesendet wird. In diesem Fall 
wird zu DATA_IN_LAST gewechselt.</li>
<li>Im Zustand <b>DATA_IN_LAST</b> wird auf das Absenden des letzten (unvollständigen bzw. leeren) Datenpakets gewartet. Danach wird zu STATUS_IN gewechselt.</li>
<li>Im Zustand <b>STATUS_IN</b> wird auf das Empfangen eines leeren 
Pakets vom Host gewartet, was den Abschluss der Transaktion 
signalisiert. Danach wird zurück zu SETUP gewechselt.</li>
<li>Im Zustand <b>STATUS_OUT</b> wird auf das Absenden eines leeren Pakets zum Signalisieren des Erfolgs gewartet. Danach wird zu SETUP gewechselt.</li></ul>
<p>Wenn im Fehlerfall zu SETUP zurückgegangen wird, wird der Endpoint 
auf "STALL" konfiguriert, sodass der Host den Fehler erkennt. Der 
Empfang des nächsten Setup-Pakets setzt diesen Zustand automatisch in 
der Peripherie zurück. In einer neuen Member-Variable m_state, die in 
ControlEP das alte m_sendStatus ersetzt, speichern wir über das enum den
 aktuellen Zustand dieses Endpoints.
</p><p>Um "OUT" Data-Stages zu unterstützen, brauchen wir in ControlEP 
eine neue Funktion dataOutStage, welche diese initiiert. Dazu gehört 
noch ein neuer Callback onDataOut, der aufgerufen wird, wenn der 
Datenblock empfangen wurde. Um längere Datenblöcke übertragen zu können,
 brauchen wir einige neue Member-Variablen:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">/// Datenpuffer für zu sendende/empfangende Daten.</span>
<span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">m_data</span><span class="p">;</span><span class="w"></span>
<span class="c1">/// Gesamtzahl zu übertragender Bytes</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">m_count</span><span class="p">;</span><span class="w"></span>
<span class="c1">/// Verbleibende Anzahl zu übertragender Bytes</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">m_remaining</span><span class="p">;</span><span class="w"></span>
<span class="c1">/// Aktueller Zustand des Zustandsautomaten</span>
<span class="n">CTRL_STATE</span><span class="w"> </span><span class="n">m_state</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Darin speichern wir einen Zeiger auf die als nächstes zu übertragenen
 Daten, sowie die Gesamtmenge und die verbleibende Menge an Bytes. 
Eigentlich brauchen wir zwei Zeiger - einen vom Typ "const uint8_t*" zum
 Senden, und einen vom Typ "uint8_t*" zum Empfangen. Ersterer kann nicht
 zum Empfangen genutzt werden weil er nicht schreibbar ist, und 
letzterer nicht zum Senden weil dataInStage einen "const"-Pointer 
erhält. Da aber immer nur einer davon gleichzeitig gebraucht wird, 
würden wir so Speicher verschwenden. Stattdessen nutzen wir nur einen 
"uint8_t*"-Pointer, und nutzen in dataInStage einen "const_cast", um das
 "const" loszuwerden. Das ist zwar unelegant, aber nicht verboten da wir
 ja beim Senden nie auf m_data schreiben, obwohl es dann nicht "const" 
ist.
</p><p>Jetzt müssen wir in den Callbacks onTransmit, onReceive und onReset die einzelnen Schritte durchführen.
</p>
<ul><li>In <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/master/src/usb.cc#L312">onReset</a> wird der ganze Automat zurückgesetzt.</li>
<li>Das Verhalten von <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/master/src/usb.cc#L322">onReceive</a> ändert sich je nach Zustand
<ul><li>Beim Empfang von Setup-Paketen wird immer onSetupStage aufgerufen</li>
<li>Sonst wird im Zustand STATUS_IN ein leeres Paket verarbeitet und onStatusStage aufgerufen</li>
<li>Im Zustand DATA_OUT wird werden die empfangenen Daten nach m_data 
gespeichert, und wenn das Ende des Transfers erkannt wurde, onDataOut 
aufgerufen.</li></ul></li>
<li>Ähnliches gilt für <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/master/src/usb.cc#L370">onTransmit</a>:
<ul><li>Im Zustand DATA_IN wird berechnet, ob als nächstes ein volles, 
unvollständiges oder leeres Paket gesendet werden muss und entsprechend 
entschieden, ob danach wieder DATA_IN oder DATA_IN_LAST folgt.</li>
<li>Im Zustand DATA_IN_LAST wird nach STATUS_IN gewechselt, der Empfang 
eines leeren Pakets als Bestätigung erwartet und onDataIn aufgerufen.</li>
<li>Im Zustand STATUS_OUT wird wieder nach SETUP gewechselt, und onStatusStage aufgerufen.</li></ul></li></ul>
<p>In <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/master/src/usb.cc#L429">dataInStage</a>
 ist eine ähnliche Fallunterscheidung nötig, um zu entscheiden, was für 
ein Paket gesendet wird und ob DATA_IN oder DATA_IN_LAST betreten wird. <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/master/src/usb.cc#L458">dataOutStage</a> ist relativ simpel und bereitet nur den Empfang vor. <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/blob/master/src/usb.cc#L472">statusStage</a>
 muss nur an die geänderte Zustandsdarstellung angepasst werden.
Weitere Änderungen des restlichen Codes sind nicht notwendig. So können 
insbesondere mit dataInStage auch direkt längere Datenblöcke gesendet, 
und damit größere Deskriptoren abgerufen werden. Das wird im nächsten 
Kapitel benötigt.
</p>
<h2 class="mw-header"><a id="Virtueller_COM-Port" href="#Virtueller_COM-Port" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Virtueller COM-Port</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=48" title="Abschnitt bearbeiten: Virtueller COM-Port">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="https://www.mikrocontroller.net/articles/Datei:USB_VCP_Testen.JPG" class="image"><img alt="" src="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/300px-USB_VCP_Testen.JPG" decoding="async" class="thumbimage" srcset="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/450px-USB_VCP_Testen.JPG 1.5x, USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/600px-USB_VCP_Testen.JPG 2x" width="300" height="200"></a>  <div class="thumbcaption"><div class="magnify"><a href="https://www.mikrocontroller.net/articles/Datei:USB_VCP_Testen.JPG" class="internal" title="vergrößern"></a></div>Testen des VCP mithilfe eines Arduinos</div></div></div><p>Als
 komplexeres Beispiel soll nun ein VCP, d.h. ein Adapter von USB auf den
 Serial-Port, implementiert werden. Dafür soll die Standard-USB-Klasse 
CDC ("communications device class") genutzt werden. Diese definiert eine
 ganze Reihe verschiedener Kommunikations-Geräte, darunter die 
Unterkategorie "PSTN" für alles, was mit dem analogen Telefonnetz 
verbunden wird (Fax, Telefon, Modem). Darin steht die Unterklasse ACM 
("abstract control model") für klassische Analog-Modems zur Verfügung, 
bei der die Daten (insb. AT-Kommandos) durch USB durchgeleitet werden. 
CDC-ACM ist also dafür gedacht, als USB-Serial-Adapter speziell für 
Analog-Modems zu fungieren. Die Betriebssysteme legen für CDC-ACM-Geräte
 einen COM-Port an, auf den dann per Einwahlsoftware zugegriffen werden 
kann, wie COM1 unter Windows und /dev/ttyACM0 unter Linux. Tatsächlich 
kann man aber auch mit beliebiger anderer Software darauf zugreifen und 
auch beliebige andere Geräte an solch einen Adapter anschließen. Daher 
wird diese Klasse hauptsächlich als allgemeiner USB-Serial-Adapter 
genutzt, weil die Betriebssysteme bereits Treiber dafür mitliefern und 
die Haupt-Anwendung der Analog-Modems ohnehin obsolet ist. Daher soll 
auch im folgenden Beispiel ein CDC-ACM-Gerät implementiert werden, 
welches die Daten auf die UART-Peripherie des Controllers umleitet. 
Alternativ könnte man die Daten auch direkt in Software für etwas 
anderes verarbeiten, und somit den Zugriff auf das Gerät per 
Terminal-Software erlauben - hierbei verliert man aber einige der 
Vorteile von USB. Im Beispielprojekt erfolgt die Implementierung des VCP
 im <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/tree/vcp">branch vcp</a>.
</p><h3 class="mw-header"><a id="Deskriptoren_für_CDC" href="#Deskriptoren_für_CDC" title="Link to this section" class="mw-headline-headanchor"></a><span id="Deskriptoren_f.C3.BCr_CDC"></span><span class="mw-headline">Deskriptoren für CDC</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=49" title="Abschnitt bearbeiten: Deskriptoren für CDC">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Weil die CDC-Klasse so viele verschiedene Gerätearten unterstützt, 
muss das konkrete Gerät relativ kompliziert deklariert werden. Als 
erstes muss im Device Deskriptor die Klasse auf "2" gesetzt werden, und 
die SubClass und Protocol beide auf 0. Es wird immer noch nur 1 
Konfiguration gebraucht, aber darin müssen für jeden Port 2 Interfaces 
angelegt werden, also in Summe 6. Daher wird bNumInterfaces auf 6 
gesetzt. Das erste Interface ist jeweils ein "Communications Class 
Interface", und erhält die Werte bInterfaceClass=2, bInterfaceSubClass=2
 und bInterfaceProtocol=1. Das definiert dieses Interface als CDC-ACM 
mit AT-Kommandos. Über den einzigen Endpoint von diesem Interface, auch 
management element genannt, werden nur Meta-Informationen übertragen - 
im Fall von ACM sind das u.a. der Zustand der Flusskontroll-Leitungen 
DSR und DCD. Das werden wir aber der Einfachheit halber nicht 
implementieren, aber wir müssen dennoch das Interface mit seinem 
IN-Endpoint vom Typ "Interrupt" im Deskriptor anlegen. Das zweite 
Interface ist das "Data Class Interface" mit den Werten 
bInterfaceClass=0xA, bInterfaceSubClass=0 und bInterfaceProtocol=0. 
Dieses enthält einen bidirektionalen Bulk-Endpoint, über welchen die 
eigentlichen Daten für den seriellen Port übertragen werden.
Nach dem Deskriptor für das Communications Class Interface müssen wir 
noch weitere CDC-spezifische Deskriptoren hinzufügen:
</p>
<ul><li>Als erstes folgt ein "Header Functional Descriptor", dessen 
einzige Information außer Größe und Typ die Version der 
CDC-Spezifikation ist.</li>
<li>Es wird "Union Interface Functional Descriptor" benötigt, welcher 
die beiden Interfaces zu einer funktionalen Einheit verbindet. Dort wird
 die Nummer unseres Communications Class Interface als "Control 
Interface" angegeben, und die des Data Class Interface als Subordinate 
Interface.</li>
<li>Im "Abstract Control Management Functional Descriptor" wird in einem
 Bitfeld die Fähigkeiten des Geräts angegeben. Dort werden wir Bit 1 
setzen, um anzuzeigen dass das Gerät die Befehle Set_Line_Coding, 
Set_Control_Line_State und Get_Line_Coding unterstützt. Das wird 
gebraucht, um die Baudrate am Host einstellen zu können.</li>
<li>Im "Call Management Functional Descriptor" geben wir an, dass das 
Gerät kein Call Management unterstützt - es ist schließlich kein echtes 
Modem vorhanden.</li></ul>
<p>Für die Details der Deskriptoren sei auf die CDC-Spezifikation 
verwiesen. In der usb_desc_helper.hh sind auch für die CDC-Deskriptoren 
Funktionen angelegt. Weil die Deskriptoren für die drei Ports bis auf 
die Endpoint-und Interfacenummern identisch sind, wird eine zusätzliche 
Funktion definiert, welche alles zusammenfasst, was nach dem 
Configuration Descriptor pro Port folgt. Damit sieht die Definition von 
Device- und Configuration-Deskriptor so aus:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * iInterface gibt den Index des Management-Interface an (für Notifications), das Daten</span>
<span class="cm"> * Interface wird dann als iInterface+1 angenommen. iMgmtEP und iDataEP geben die Adressen der jeweiligen</span>
<span class="cm"> * Endpoints an.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Util</span><span class="o">::</span><span class="n">EncChar</span><span class="p">,</span><span class="w"> </span><span class="mi">58</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vcpDescriptor</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">iInterface</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">iMgmtEP</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">iDataEP</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">Util</span><span class="o">::</span><span class="n">concatArrays</span><span class="o">&lt;</span><span class="n">Util</span><span class="o">::</span><span class="n">EncChar</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">		</span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">interface</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">			</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">iInterface</span><span class="p">),</span><span class="w">					</span><span class="c1">// bInterfaceNumber</span>
<span class="w">				</span><span class="mi">0</span><span class="p">,</span><span class="w">												</span><span class="c1">// bAlternateSetting</span>
<span class="w">				</span><span class="mi">1</span><span class="p">,</span><span class="w">												</span><span class="c1">// bNumEndpoints</span>
<span class="w">				</span><span class="mh">0x2</span><span class="p">,</span><span class="w">											</span><span class="c1">// bInterfaceClass		Communications Interface</span>
<span class="w">				</span><span class="mh">0x2</span><span class="p">,</span><span class="w">											</span><span class="c1">// bInterfaceSubClass	Abstract Control Model</span>
<span class="w">				</span><span class="mh">0x1</span><span class="p">,</span><span class="w">											</span><span class="c1">// bInterfaceProtocol	AT</span>
<span class="w">				</span><span class="mi">0</span><span class="w">												</span><span class="c1">// iInterface</span>
<span class="w">		</span><span class="p">),</span><span class="w"></span>

<span class="w">			</span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">CDC</span><span class="o">::</span><span class="n">classSpecific</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">				</span><span class="mh">0x10</span><span class="p">,</span><span class="w">	</span><span class="c1">// bcdCDC</span>
<span class="w">				</span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">CDC</span><span class="o">::</span><span class="n">unionInterface</span><span class="p">(</span><span class="w"></span>
<span class="w">					</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">iInterface</span><span class="p">),</span><span class="w">			</span><span class="c1">// bControlInterface</span>
<span class="w">					</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">iInterface</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">		</span><span class="c1">// bSubordinateInterfaces</span>
<span class="w">				</span><span class="p">),</span><span class="w"></span>
<span class="w">				</span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">CDC</span><span class="o">::</span><span class="n">ACM</span><span class="p">(</span><span class="w"></span>
<span class="w">						</span><span class="mi">2</span><span class="w">										</span><span class="c1">// bmCapabilities	Unterstützung für Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding,</span>
<span class="w">				</span><span class="p">),</span><span class="w"></span>
<span class="w">				</span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">CDC</span><span class="o">::</span><span class="n">callManagement</span><span class="p">(</span><span class="w"></span>
<span class="w">						</span><span class="mi">0</span><span class="p">,</span><span class="w">										</span><span class="c1">// bmCapabilities	Kein Call Management</span>
<span class="w">						</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">iInterface</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">	</span><span class="c1">// bDataInterface</span>
<span class="w">				</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="p">),</span><span class="w"></span>

<span class="w">			</span><span class="c1">// Notification endpoint - wird im Beispiel nicht genutzt</span>
<span class="w">			</span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">endpoint</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">				</span><span class="mh">0x80</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">iMgmtEP</span><span class="p">,</span><span class="w">									</span><span class="c1">// bEndpointAddress		IN</span>
<span class="w">				</span><span class="mi">3</span><span class="p">,</span><span class="w">												</span><span class="c1">// bmAttributes			Interrupt</span>
<span class="w">				</span><span class="mi">8</span><span class="p">,</span><span class="w">												</span><span class="c1">// wMaxPacketSize</span>
<span class="w">				</span><span class="mi">255</span><span class="w">												</span><span class="c1">// bInterval</span>
<span class="w">			</span><span class="p">),</span><span class="w"></span>

<span class="w">		</span><span class="c1">// Data Interface (Payload transfer)</span>
<span class="w">		</span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">interface</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">			</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">iInterface</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w">				</span><span class="c1">// bInterfaceNumber</span>
<span class="w">			</span><span class="mi">0</span><span class="p">,</span><span class="w">													</span><span class="c1">// bAlternateSetting</span>
<span class="w">			</span><span class="mi">2</span><span class="p">,</span><span class="w">													</span><span class="c1">// bNumEndpoints</span>
<span class="w">			</span><span class="mh">0xA</span><span class="p">,</span><span class="w">												</span><span class="c1">// bInterfaceClass		Data Interface</span>
<span class="w">			</span><span class="mh">0x0</span><span class="p">,</span><span class="w">												</span><span class="c1">// bInterfaceSubClass	Unused</span>
<span class="w">			</span><span class="mh">0x0</span><span class="p">,</span><span class="w">												</span><span class="c1">// bInterfaceProtocol	No class specific protocol</span>
<span class="w">			</span><span class="mi">0</span><span class="w">													</span><span class="c1">// iInterface</span>
<span class="w">		</span><span class="p">),</span><span class="w"></span>
<span class="w">			</span><span class="c1">// Endpoints für eigentliche Nutzdaten</span>

<span class="w">			</span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">endpoint</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">				</span><span class="n">iDataEP</span><span class="p">,</span><span class="w">										</span><span class="c1">// bEndpointAddress			OUT</span>
<span class="w">				</span><span class="mi">2</span><span class="p">,</span><span class="w">												</span><span class="c1">// bmAttributes				Bulk</span>
<span class="w">				</span><span class="n">dataEpMaxPacketSize</span><span class="p">,</span><span class="w">							</span><span class="c1">// wMaxPacketSize</span>
<span class="w">				</span><span class="mi">10</span><span class="w">												</span><span class="c1">// bInterval</span>
<span class="w">			</span><span class="p">),</span><span class="w"></span>
<span class="w">			</span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">endpoint</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">				</span><span class="mh">0x80</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">iDataEP</span><span class="p">,</span><span class="w">									</span><span class="c1">// bEndpointAddress			IN</span>
<span class="w">				</span><span class="mi">2</span><span class="p">,</span><span class="w">												</span><span class="c1">// bmAttributes				Bulk</span>
<span class="w">				</span><span class="n">dataEpMaxPacketSize</span><span class="p">,</span><span class="w">							</span><span class="c1">// wMaxPacketSize</span>
<span class="w">				</span><span class="mi">10</span><span class="w">												</span><span class="c1">// bInterval</span>
<span class="w">			</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Die hier im Device Deskriptor angegebene Device Class markiert das Gerät als Composite Device.</span>
<span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">deviceDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">device</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">			</span><span class="mh">0x200</span><span class="p">,</span><span class="w">		</span><span class="c1">// bcdUSB</span>
<span class="w">			</span><span class="mh">0x02</span><span class="p">,</span><span class="w">		</span><span class="c1">// bDeviceClass		Communication Device Class</span>
<span class="w">			</span><span class="mh">0x00</span><span class="p">,</span><span class="w">		</span><span class="c1">// bDeviceSubClass	Unused</span>
<span class="w">			</span><span class="mh">0x00</span><span class="p">,</span><span class="w">		</span><span class="c1">// bDeviceProtocol	Unused</span>
<span class="w">			</span><span class="mi">64</span><span class="p">,</span><span class="w">			</span><span class="c1">// bMaxPacketSize0</span>
<span class="w">			</span><span class="mh">0xDEAD</span><span class="p">,</span><span class="w">		</span><span class="c1">// idVendor		TODO - anpassen</span>
<span class="w">			</span><span class="mh">0xBEEF</span><span class="p">,</span><span class="w">		</span><span class="c1">// idProduct	TODO - anpassen</span>
<span class="w">			</span><span class="mh">0x0100</span><span class="p">,</span><span class="w">		</span><span class="c1">// bcdDevice</span>
<span class="w">			</span><span class="mi">1</span><span class="p">,</span><span class="w">			</span><span class="c1">// iManufacturer, entspricht dem Index des strManufacturer-Deskriptors</span>
<span class="w">			</span><span class="mi">2</span><span class="p">,</span><span class="w">			</span><span class="c1">// iProduct, entspricht dem Index des strProduct-Deskriptors</span>
<span class="w">			</span><span class="mi">3</span><span class="p">,</span><span class="w">			</span><span class="c1">// iSerialNumber, entspricht dem Index des strSerial-Deskriptors</span>
<span class="w">			</span><span class="mi">1</span><span class="w">			</span><span class="c1">// bNumConfigurations</span>
<span class="w">		</span><span class="p">);</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">confDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">USB20</span><span class="o">::</span><span class="n">configuration</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">			</span><span class="mi">6</span><span class="p">,</span><span class="w">			</span><span class="c1">// bNumInterfaces</span>
<span class="w">			</span><span class="mi">1</span><span class="p">,</span><span class="w">			</span><span class="c1">// bConfigurationValue</span>
<span class="w">			</span><span class="mi">0</span><span class="p">,</span><span class="w">			</span><span class="c1">// iConfiguration</span>
<span class="w">			</span><span class="mh">0x80</span><span class="p">,</span><span class="w">		</span><span class="c1">// bmAttributes</span>
<span class="w">			</span><span class="mi">250</span><span class="p">,</span><span class="w">		</span><span class="c1">// bMaxPower (500mA)</span>

<span class="w">			</span><span class="c1">// Füge die Deskriptoren für die VCPs hinzu</span>
<span class="w">			</span><span class="n">vcpDescriptor</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"></span>
<span class="w">			</span><span class="n">vcpDescriptor</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"></span>
<span class="w">			</span><span class="n">vcpDescriptor</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
</pre></div>
<p>Wird das so markierte Gerät angeschlossen, zeigt der Linux-Kernel folgende Meldung:
</p>
<pre>[39541.301191] usb 2-2: new full-speed USB device number 24 using xhci_hcd
[39541.431269] usb 2-2: New USB device found, idVendor=dead, idProduct=beef
[39541.431275] usb 2-2: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[39541.431277] usb 2-2: Product: Fluxkompensator
[39541.431279] usb 2-2: Manufacturer: ACME Corp.
[39541.431281] usb 2-2: SerialNumber: 42-1337-47/11
[39541.432081] cdc_acm 2-2:1.0: ttyACM0: USB ACM device
[39541.432508] cdc_acm 2-2:1.2: ttyACM1: USB ACM device
[39541.432968] cdc_acm 2-2:1.4: ttyACM2: USB ACM device
</pre>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="https://www.mikrocontroller.net/articles/Datei:Windows_3x_VCP.png" class="image"><img alt="" src="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/300px-Windows_3x_VCP.webp" decoding="async" class="thumbimage" srcset="USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/450px-Windows_3x_VCP.webp 1.5x, USB-Tutorial%20mit%20STM32%20%E2%80%93%20Mikrocontroller.net-Dateien/600px-Windows_3x_VCP.webp 2x" width="300" height="220"></a>  <div class="thumbcaption"><div class="magnify"><a href="https://www.mikrocontroller.net/articles/Datei:Windows_3x_VCP.png" class="internal" title="vergrößern"></a></div>Der 3x-VCP im Geräte-Manager</div></div></div><p>Entsprechend
 werden die Dateien /dev/ttyACM0, /dev/ttyACM1, /dev/ttyACM2 angelegt. 
Die sind natürlich noch nicht benutzbar, weil wir noch nichts auf den 
entsprechenden Endpoints übertragen.
</p><p>Unter Windows funktioniert das Gerät so leider noch nicht. Der 
Windows-CDC-Treiber kann nicht direkt mit Geräten umgehen, die mehrere 
Ports haben. Stattdessen ist es nötig, das Gerät als Verbundgerät 
("Composite Device") zu definieren, dann wird der Treiber 3x (einmal pro
 Port) geladen und wir erhalten 3 COM-Ports. Dazu setzen wir im device 
descriptor bDeviceClass=0xEF, bDeviceSubClass=0x02, 
bDeviceProtocol=0x01. Für diese neue Klasse müssen wir dann im 
Configuration Descriptor pro Port je einen "Interface Association 
Descriptor" anlegen. Dieser definiert je eine Funktion des 
Verbundgeräts. Dort geben wir an, welche Interfaces zu dieser Funktion 
gehören, indem wir den Index des ersten Interfaces (0/2/4) angeben sowie
 die Anzahl zugehöriger Interfaces (2). Außerdem müssen dort die Class, 
SubClass und Protocol des ersten Interfaces mit übernommen werden, also 
2, 2 und 1. Optional kann noch ein String-Deskriptor angegeben werden. 
Mithilfe einer entsprechenden Funktion in der usb_desc_helper.hh sieht 
das dann so aus:
</p>
<div class="mw-highlight mw-highlight-lang-c++ mw-content-ltr" dir="ltr"><pre><span></span><span class="n">EncodeDescriptors</span><span class="o">::</span><span class="n">IAD</span><span class="o">::</span><span class="n">interfaceAssociation</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">	</span><span class="n">iInterface</span><span class="p">,</span><span class="w">		</span><span class="c1">// bFirstInterface</span>
<span class="w">	</span><span class="mi">2</span><span class="p">,</span><span class="w">				</span><span class="c1">// bInterfaceCount</span>
<span class="w">	</span><span class="mh">0x02</span><span class="p">,</span><span class="w">			</span><span class="c1">// bFunctionClass</span>
<span class="w">	</span><span class="mi">2</span><span class="p">,</span><span class="w">				</span><span class="c1">// bFunctionSubClass</span>
<span class="w">	</span><span class="mi">1</span><span class="p">,</span><span class="w">				</span><span class="c1">// bFunctionProtocol</span>
<span class="w">	</span><span class="mi">4</span><span class="w">				</span><span class="c1">// iFunction</span>
<span class="p">)</span><span class="w"></span>
</pre></div>
<p>Das so definierte Gerät wird dann sowohl von Windows als auch Linux 
korrekt als 3-Fach-Serial-Adapter erkannt. Als nächstes müssen wir die 
Endpoint der Data Class Interfaces mit Leben füllen.
</p>
<h3 class="mw-header"><a id="Implementierung_der_Datenübertragung" href="#Implementierung_der_Datenübertragung" title="Link to this section" class="mw-headline-headanchor"></a><span id="Implementierung_der_Daten.C3.BCbertragung"></span><span class="mw-headline">Implementierung der Datenübertragung</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=50" title="Abschnitt bearbeiten: Implementierung der Datenübertragung">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Um alle Aspekte eines der drei VCPs zu kapseln, implementieren wir 
eine Klasse namens "VCP". Diese wird den Zugriff auf den USART mittels 
DMA steuern, die Baudrate &amp; Frame-Format konfigurieren und 
Flusskontroll-Leitungen setzen. Da USART und USB unterschiedliche 
Datenraten haben, wird für jede Richtung ein Puffer benötigt. Hier wird 
ein einfacher Doppelpuffer genutzt, der aber z.B. auf einen "richtigen" 
Ringpuffer ausgebaut werden könnte.
</p><p>Für den Zugriff auf den Bulk-Endpoint für die Nutzdaten wird die 
VCP-Klasse von der zuvor implementierten EPBuffer-Klasse ableiten und 
die drei Callbacks onReset, onReceive, onTransmit überschreiben. Der 
Konstruktor wird mit den entsprechenden Daten (Endpoint-Adresse, -Typ, 
Zeiger auf Puffer) aufgerufen. Der Management-Endpoint sollte zwar 
initialisiert werden, aber die Callbacks werden nicht gebraucht. Zu 
dessen Implementierung wird eine von EPBuffer abgeleitete Klasse 
VCP_MgmtEP erstellt, welche die Callbacks leer implementiert und dem 
Konstruktur die nötige Konfiguration übergibt. Die Puffer-Zeiger können 
"nullptr" sein, da nie receivePacket/transmitPacket aufgerufen wird. Vom
 Typ dieser Klasser erhält VCP eine Member-Variable. Damit ist VCP nun 
in der Lage Daten per USB zu senden/empfangen.
</p><p>Die VCP-Klasse enthält zwei Doppelpuffer-Instanzen, eine pro 
Richtung. Via DMA wird darin direkt gelesen/geschrieben, so wie Platz 
ist bzw. Daten verfügbar sind. Ist die empfangende Seite des 
Doppelpuffers voll, werden die Puffer getauscht, sodass die empfangenen 
Daten weitergesendet werden, und wieder Platz zum Empfangen ist. Diese 
Konstruktion hat ein Problem bei niedrigen Datenraten: Dann kann es sehr
 lange dauern, bis der Puffer voll ist und die Daten weitergeleitet 
werden. Wenn ein serielles Protokoll mit kurzen Datenpaketen genutzt 
wird, bei dem auf eine Antwort gewartet wird, bleibt die Kommunikation 
sogar ganz stecken. Daher wird auf der USB-&gt;USART Seite der Puffer 
nach dem Empfang eines Pakets sofort getauscht, und auf der 
USART-&gt;USB Seite nach Empfang eines IDLE-Frames, d.h. wenn für 
(mindestens) die Dauer eines Frames die Leitung auf 'High' war. Dies hat
 den Nachteil, dass zu Beginn einer schnellen Kommunikation die 
Effizienz sinkt.
</p><p>Auf eine genauere Erläuterung der USART-Ansteuerung wird hier 
verzichtet, weil dies nicht mehr viel mit USB zu tun hat. Einzig 
interessant ist noch die Einstellung der Schnittstellenparameter. Dazu 
sendet der Host die Anfrage "SET_LINE_CODING" mit den Parametern im 
Datenblock auf dem Default Control Endpoint 0. Über GET_LINE_CODING 
können die Parameter wieder abgefragt werden. In diesem Datenblock wird 
die gewünschte Baudrate als 32bit-Integer angegeben, aus welchem dann 
der Prescaler für die USART-Peripherie berechnet werden muss. Im 
Reference Manual ist die Berechnung des USART-Prescalers unnötig 
kompliziert dargestellt. Einfacher ist es so: Das USART-Modul wird mit 
dem Perpherietakt f_PCLK betrieben - APB2 beim USART1, und APB1 bei 
USART2 und USART3. Im Beispiel sind beim APB2 72 MHz, und 36 MHz beim 
APB1 eingestellt. Der Prescaler P ergibt sich dann bei gewünschter 
Baudrate B_w durch: P = f_PCLK / B_w. Die normale Integer-Division in 
C++ ist allerdings grundsätzlich <i>ab</i>rundend, es wäre aber 
wünschenswert richtig zu runden, um immer die nächstmögliche und nicht 
die nächste kleinere Baudrate zu erwischen. Dies kann erreicht werden, 
indem man "P = (f_PCLK + (B_w / 2)) / B_w;" rechnet. Mit dem USART lässt
 sich aber nicht jede beliebige Baudrate erreichen, sondern nur solche, 
bei der die tatsächliche über den Prescaler erreichte Baudrate "B_i = 
f_PCLK / P " um maximal 3% von der gewünschten "B_w" abweicht. Wir 
wollen also prüfen, ob die angeforderte Baudrate tatsächlich erreichbar 
ist, d.h. ob "|B_i - B_w| / B_w &lt;= 0.03" ist. Um das nicht mit 
floating-Point-Zahlen rechnen zu müssen (der Cortex-M3 hat keine FPU), 
wird das nach "|B_i - f_PCLK|*100/3 &lt;= B_i" umgestellt. Da im Code 
nur mit vorzeichenlosen Integern gerechnet wird, muss der Betrag der 
Differenz mit einer Fallunterscheidung berechnet werden. So können wir 
letzendlich jede Baudrate einstellen, die vom Controller unterstützt 
wird, wozu alle üblichen Standard-Baudraten gehören. Bei nicht 
unterstützten wird ein Fehler an den PC zurückgesendet und die Baudrate 
nicht übernommen.
</p><p>Übrig bleibt lediglich noch das Setzen der 
Flusskontroll-Leitungen DTR und RTS über den Request 
SET_CONTROL_LINE_STATE. Das funktioniert genauso wie das Setzen der 
LED's im Hello-World-Beispiel.
</p><p>In Summe erhalten wir so einen einfachen aber funktionsfähigen 
3-Fach-USB-Serial-Adapter, der ohne Treiber funktioniert und viele 
Baudraten unterstützt.
</p>
<h2 class="mw-header"><a id="Stromversorgung_per_USB" href="#Stromversorgung_per_USB" title="Link to this section" class="mw-headline-headanchor"></a><span class="mw-headline">Stromversorgung per USB</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;action=edit&amp;section=51" title="Abschnitt bearbeiten: Stromversorgung per USB">Bearbeiten</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Da nun die Grundlagen der USB-Ansteuerung geklärt sind, kann ein 
weiteres einfaches Beispiel gezeigt werden: Häufig stellt sich die 
Frage, wie eigene Projekte über USB versorgt werden können. 
Standardmäßig erlaubt USB angeschlossenen Geräten, nur maximal 100mA 
Strom aufzunehmen. Benötigt ein Gerät unerlaubt mehr, kann der Host es 
abschalten oder sogar Schaden nehmen. Ein Gerät kann per Software bis zu
 500mA anfordern, indem es diesen Strom im Configuration Descriptor 
einträgt. Nur wenn der PC diese Konfiguration per "SET_CONFIGURATION" 
aktiviert, darf das Gerät den Strom aufnehmen. Der PC kann die Freigabe 
auch wieder zurücknehmen, indem er "SET_CONFIGURATION" mit "0" als 
Parameter sendet. Das explizite Einschalten ist wichtig, um auch bei der
 Nutzung von bus powered Hubs eine Überlast der root ports zu vermeiden.
 Das Verhalten der verschiedenen Host-Implementation variiert allerdings
 stark; viele Hosts nehmen eine zu hohe Stromaufnahme nicht übel.
</p><p>Auf Basis der bereits implementierten Funktionen kann sehr 
einfach eine Firmware erstellt werden, welche die maximalen 500mA 
anfordert und nur bei Freigabe einen Pin einschaltet, mit dem dann der 
eigene Verbraucher ein/aus geschaltet werden kann. Damit Windows das 
Gerät ohne Treiberinstallation akzeptiert, wird es wieder als WinUSB 
Device implementiert, welches aber keine PC-Software benötigt und keine 
weitere Kommunikation unterstützt. Es wird lediglich enumeriert und 
befindet sich dann im "Leerlauf". Es reagiert auf die 
SET_CONFIGURATION-Befehle mit Ein/Ausschalten eines GPIO's. Im 
Beispielcode wird hier PA5 genutzt, welcher auf dem Olimexino die LED1 
schaltet und auf den Arduino-Pin D13 geführt ist. Pin und 
Stromanforderung können in der "src/main.hh" angepasst werden. Im 
Beispielcode ist dies im <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/tree/usbpower">usbpower-Branch</a> implementiert. Es ist auch ein fertiges <a rel="nofollow" class="external text" href="https://github.com/Erlkoenig90/f1usb/releases">Image</a> zum direkten Flashen verfügbar.
</p>
<!-- 
NewPP limit report
Cached time: 20220125185320
Cache expiry: 86400
Reduced expiry: false
Complications: []
CPU time usage: 0.555 seconds
Real time usage: 19.506 seconds
Preprocessor visited node count: 469/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 177958/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key uc_wiki:pcache:idhash:9686-0!canonical and timestamp 20220125185301 and revision id 104757. Serialized with JSON.
 -->
</div></div>			<!-- /bodycontent -->
						<!-- printfooter -->
			<div class="printfooter">
			Abgerufen von „<a dir="ltr" href="https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;oldid=104757">https://www.mikrocontroller.net/index.php?title=USB-Tutorial_mit_STM32&amp;oldid=104757</a>“			</div>
			<!-- /printfooter -->
									<!-- catlinks -->
			<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="https://www.mikrocontroller.net/articles/Spezial:Kategorien" title="Spezial:Kategorien">Kategorien</a>: <ul><li><a href="https://www.mikrocontroller.net/articles/Kategorie:USB" title="Kategorie:USB">USB</a></li><li><a href="https://www.mikrocontroller.net/articles/Kategorie:STM32" title="Kategorie:STM32">STM32</a></li><li><a href="https://www.mikrocontroller.net/articles/Kategorie:Daten%C3%BCbertragung" title="Kategorie:Datenübertragung">Datenübertragung</a></li></ul></div></div>			<!-- /catlinks -->
									<div class="visualClear"></div>
			<!-- debughtml -->
						<!-- /debughtml -->

      <div class="visualClear"></div>
    </div>
	</div>
  </div></td>
  <!-- google_ad_section_end -->
      </tr>
      </tbody></table>
      <!--
      <div class="visualClear"></div>
      <div id="footer" style="clear:both">
    <div id="f-poweredbyico"><a href="https://www.mediawiki.org/"><img src="/resources/assets/poweredby_mediawiki_88x31.png" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" height="31" width="88" alt="Powered by MediaWiki" loading="lazy" /></a></div>		<ul id="f-list">
	  <li id="f-lastmod"> Diese Seite wurde zuletzt am 30. September 2021 um 10:52 Uhr bearbeitet.</li>	  	  	  	  <li id="f-about"><a href="/articles/Mikrocontroller.net:%C3%9Cber_Mikrocontroller.net" title="Mikrocontroller.net:Über Mikrocontroller.net">Über Mikrocontroller.net</a></li>	  <li id="f-disclaimer"><a href="/articles/Mikrocontroller.net:Impressum" title="Mikrocontroller.net:Impressum">Haftungsausschluss</a></li>	</ul>
      </div>-->
    </div>


<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.555","walltime":"19.506","ppvisitednodes":{"value":469,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":177958,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20220125185320","ttl":86400,"transientcontent":false}}});mw.config.set({"wgBackendResponseTime":142});});</script><div id="extwaiokist" style="display:none" v="{2c1b" q="a0ce1ccd" c="424.9" i="436" u="3.595" s="01242205" d="1" w="false" e="" m="BMe=" vn="0vdo1"><div id="extwaigglbit" style="display:none" v="{2c1b" q="a0ce1ccd" c="424.9" i="436" u="3.595" s="01242205" d="1" w="false" e="" m="BMe="></div></div></div>

  

<div class="highslide-container" style="padding: 0px; border: medium none; margin: 0px; position: absolute; left: 0px; top: 0px; width: 100%; z-index: 1001; direction: ltr;"><a class="highslide-loading" title="Click to cancel" href="javascript:;" style="position: absolute; top: -9999px; opacity: 0.75; z-index: 1;">Loading...</a><div style="display: none;"></div><table style="padding: 0px; border: medium none; margin: 0px; visibility: hidden; position: absolute; border-collapse: collapse; width: 0px;" cellspacing="0"><tbody style="padding: 0px; border: medium none; margin: 0px;"><tr style="padding: 0px; border: medium none; margin: 0px; height: auto;"><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px;"></td><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px;"></td><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px;"></td></tr><tr style="padding: 0px; border: medium none; margin: 0px; height: auto;"><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px;"></td><td style="padding: 0px; border: medium none; margin: 0px; position: relative;" class="drop-shadow highslide-outline"></td><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px;"></td></tr><tr style="padding: 0px; border: medium none; margin: 0px; height: auto;"><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px;"></td><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px;"></td><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px;"></td></tr></tbody></table></div></body></html>