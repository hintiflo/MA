%%% File encoding: UTF-8
%%% äöüÄÖÜß  <-- no German umlauts here? Use an UTF-8 compatible editor!

%%% Magic comments for setting the correct parameters in compatible IDEs
% !TeX encoding = utf8
% !TeX program = pdflatex 
% !TeX spellcheck = de_DE
% !BIB program = biber

\documentclass[master,english,smartquotes,apa]{hgbthesis}
% Valid options in [..]: 
%    Type of work: 'diploma', 'master' (default), 'bachelor', 'internship' 
%    Main language: 'german' (default), 'english'
%    Turn on smart quote handling: 'smartquotes'
%    APA bibliography style: 'apa'
%%%-----------------------------------------------------------------------------

\RequirePackage[utf8]{inputenc} % Remove when using lualatex or xelatex!

\graphicspath{{images/}}  % Location of images and graphics
\logofile{logo}           % Logo file: images/logo.pdf (no logo: \logofile{})
\bibliography{references} % Biblatex bibliography file (references.bib)

% \usepackage[table]{xcolor}
\usepackage{longtable}

%%%-----------------------------------------------------------------------------
% Title page entries
%%%-----------------------------------------------------------------------------

\title{ Application of Software Quality Measures to Bare-metal Firmware for Optical Coherence Tomography}
\author{Florian Hinterleitner}
\programname{embedded systems design}
\programtype{Fachhochschul-Masterstudiengang}
\placeofstudy{Hagenberg}
\dateofsubmission{2022}{06}{15} % {YYYY}{MM}{DD}
\advisor{Langer, Rankl, Zorin} % optional
%\strictlicense % restrictive license instead of Creative Commons (discouraged!)
\definecolor{gray}{gray}{.80}

\input{_newcomms.tex}

\begin{document}
\frontmatter                                   % Front part (roman page numbers)
\maketitle

\tableofcontents

% \include{front/preface} % A preface is optional
\include{front/abstract}		
\include{front/kurzfassung}			
\mainmatter                                    % Main part (arabic page numbers)
\include{chapters/introduction}
\include{chapters/fundamentals}
% \include{chapters/_fundamentals}

	
	\chapter{Requirements}
	\label{cha:Requirements}
		% Allgemeine REQs an FW, RT (und evtl design-for-testability)
		% \section{Firmware-Requirements}
		\TODO{Formulieren}
		Two meetings, including all stakeholders of the OCTane, resulted in all requirements towards the OCTane and especially the firmware running on it. As these are imposed by the stakeholders, or, in other words, by the users of the OCTane, they are called 'user requirements'. Accompanying tags in the form 'RU-xx' allow for tracing relations between a requirement and according test-cases or points of implementation inside the source-code.
			\section{User requirements}
				\input{src/_REQS.tex}
		\pagebreak
			\section{USB-Protocol}
		SCPI Commands can be in 'short form', defined by the capital letters, or in 'long form', defined by the whole string. OCTane accepts both forms as commands and is case-insensitive.

			{	\scriptsize
				\input{src/_scpiRecendt.tex}
			}
			Table ~\ref{USB-Protocol-responses} specifies the responses by the OCTane, if they are not described sufficiently in the previous table.

			{	\scriptsize
				\input{src/_scpiStd.tex}
			}
			
	\subsection{Analogue outputs Resolution and LSB}
	mapping 20Vpp Voltage space to a resolution of 16bit
	\begin{itemize}
		\item 0 ... 30000 ... 60000
		\item 1000 ... 31000 ... 61000
		\item 0 ... 32767 ... 65535
		\item ???
	\end{itemize}
	$\rightarrow$ LSB \^{=} ...mV

			\subsection{Load-Hypothesis, Fault-Hypothesis}
			\subsection{Traceability-Matrix}
			Linking Requirements by there tags, to the SW-modules, where they are fulfilled
			\subsection{V-Model}
			\subsection{Test-cases}
			Automated test-cases are the primary method to ensure code-quality, because they allow for the assessment of functionalities against requirements and produce according documentation of conducted tests. Furthermore, they help identifying  errors in case of failures and secure implemented functionalities during future adaptions. To demonstrate a complete assessment of the firmware, for every existing user-requirement, at least one test-case is necessary. For practical reasons, these cases must be implemented as python-scripts, running on a proxy host-device, controlling the device under test via USB. The first practical aspect, being, that the resulting test-data are directly available on a device with capable processing power and high memory capacity, facilitating the automated generation of test-reports. The python programming language provides the package 'pytest-html', allowing for the automated generation of test-reports in HTML-format. Every test-case has to be simple enough, to render verification of the test-code itself unnecessary. A test-case, so complex, that i would require a superordinate test-case, indicates, that said test-case should be split into several cases of lesser respective complexity. Fig. ~\ref{testCaseExample} contains an exemplary test-case, assessing the devices correct reply to an identification query. \TODO{Quelle: scpi document}
			
			\bildGr{h!}{testCaseExample}{testCaseExample}{testCaseExample}{0.75\textwidth}
			The general procedure of this test-case consists of 
			\begin{itemize} \setlength\itemsep{1px}
			\item Sending a command to the device under test,
			\item Gathering resulting test-data and
			\item Verification of retrieved data against requirements.
			\end{itemize}
			Upon execution via 'pytest-html', this test-case either results as 'passed' or 'failed', depending on the contained assertions. Furthermore, it causes an entry in the resulting report-file, likewise to the extract in fig. ~\ref{reportExample}
			
			\bildGr{h!}{reportExample}{reportExample}{reportExample}{0.75\textwidth}
			
			In case of commands resulting in digital, analogue or serial output-signals, these signals shall be automatically measured as part of a test-case. Automated measurement is required if performable with justifiable effort and available measurement instruments. Apart from this method of fully automated testing, few requirements demand assessment in a manual fashion. For example, oscillograms of the resulting analogue signals require evaluation buy the eye of a skilled engineer. Automation of this process via spectral analysis or automated comparison with reference signals would require unjustifiable effort, compared to an evaluation via visual inspection. \\
			Test-cases, usually, belong to one of the following classes, \TODO{according to the V-Model}:
			\subsection{Unit-Tests}
			Unit-tests are test-cases that evaluate the correctness of single functions, methods or procedures. A single variable, array or data-set also constitutes such a unit, if the contained data demands deliberate assessment via a test-case. Viable inputs exist in the form of binary values with separate cases for 'true' and 'false'. In case of numerical input, be they of integer or floating-point nature, the boundary-value and equivalence-class methods deliver suitable input values. For inputs in text form, all specified valid texts, and at least one invalid text form a set of useful input values. \cite{jorgensen13}
			\subsection{Integration-Tests}
			The next level of tests concern the interactions between units and their correct cooperation to form correctly working modules and sub-systems. A major focus in integration testing lies on the verification of units and modules to ensure their correct interaction. As this aspect is of a lesser concern during unit-testing, integration-testing is an established branch of verification in its own right. Furthermore, side-effects of units, which are hardly a concern during unit-testing, are important aspects during integration-testing. Testing and demonstrating seamless interoperability and collaboration of modules are the prime objectives. \cite{SpilSoft2005} % \TODO{welche inputs? Oder: beschreibung der integrations-Art nach ISTQB S. 56} Similar to a unit-test for text-driven functions, an integration test has to contain all possible valid inputs and at least one invalid. 
			The strategy of integration, happening during implementation has significant influence on the design of suitable integration-tests. 
			\begin{itemize} \setlength\itemsep{1px}
			\item Top-down integration approaches the code under test from its entry point and external interfaces, non-existing sub-systems require replacement through stubs delivering dummy-data.
			\item Bottom-up integration builds modules and subs-systems based upon existing low-level functions, while non-existing higher-ranking systems require replacement through test-drivers delivering dummy-commands.
			\item Ad hoc integration is the least formal integration-strategy, where components undergo integration directly after integration, regardless of their level or rank within the complete system. The effort in planning integration is negligible, while non-existing components demand higher effort for their replacements. Furthermore, the lack of a thoroughly planned integration phase might diffuse into the resulting software exhibiting an erratic and patchy structure.
			\item Backbone integration \cite{Beizer90}
			\BLUE{
			A skeleton or backbone is built and components are gradually integrated into it 
			Advantage: Components can be integrated in any order.
			Disadvantage: A possibly labor-intensive skeleton or backbone is required.
			}
			\end{itemize} 
			
			\subsection{System-Tests}
			% https://de.wikipedia.org/wiki/Heisenbug
			TODO{kann ma den da reinschummeln?}
			\cite{Beizer95}
			\subsection{Load/Fault Tests}
			

			\subsection{Code Coverage}
			Code Coverage is an accompanying metric to test-cases, indicating their accuracy of assessment. Fig ~\ref{gcovReportDebugUnit01} depicts an extract of the coverage report of one submodule and ~\ref{gcovReport01} contains a composite report about code coverage over the whole firmware-project.
			
			\bildGr{h!}{gcovReportDebugUnit01}{gcovReportDebugUnit01}{gcovReportDebugUnit01}{0.75\textwidth}
			\bildGr{h!}{gcovReport01}{gcovReport01}{gcovReport01}{0.75\textwidth}
			
	\chapter{Concept}
	\label{cha:Concept}
		\section{ system architecture }
			Modules-Skizze + HW-Graph und ein meta-graph der diese verbindet.
		\section{FSM}

		\begin{figure}[H]
			\center
			\includegraphics[width=0.75\textwidth]{src/_mainFSM_neato.pdf}
			\caption{overarching Finite state machine}
			\label{fig:FSM}
		\end{figure}


		\section{Modules of the Firmware}
		\begin{figure}[H]
			\center
			\includegraphics[width=\textwidth]{src/_FW-Modules.pdf}
			\caption{Modular structure}
			\label{fig:_FW-Modules}
		\end{figure}
	

		\subsubsection{Triggers and Voltage - Outputs}
		association of Triggers and their analogue outputs
		\begin{itemize}
			\item TriggerB $\rightarrow$ SourceB $\rightarrow$ Vout1
			\item TriggerA $\rightarrow$ SourceA $\rightarrow$ Vout2
		\end{itemize}
		\subsection{Standard operation procedures (SOP)}
		{	\scriptsize
			\input{src/_SOPs.tex}
		}

		\section{ Measuring code coverage on a bare-metal sys }
		
		\bildGr{h!}{coverageFlow}{coverageFlow}{coverageFlow}{0.75\textwidth}
		
		
		
	\chapter{Implementation}
	\label{cha:Implementation}
		\section{Trigger-Diagramme}
		\section{Timer usage}
			\begin{itemize} \setlength\itemsep{1px}
			\item 3 capture compare timers for signal-generation
			\item 1 timer basic for kex debouncing 
			\item 1 timer basic for reading timeouts
			\item 1 timer basic for flashing LEDs
			\end{itemize}
		\subsubsection{Trigger-Lines and Timers}
		utilisation of the output compare - timers
		\begin{itemize}
			\item TrigA \^{=} $TRIG\_2$  \^{=} PB3 $\leftarrow$ $TIM2_CH2$
			\item TrigB \^{=} $EN\_3$    \^{=} PC6 $\leftarrow$ $TIM8_CH1$
			\item TrigC \^{=} $EN\_4$    \^{=} PC7 $\leftarrow$ $TIM3_CH2$
		\end{itemize}
			% 3 Timers necessary, old concept: double frequency and on modulo 2 will be decided if PinSet and DACwrite, or PinClear
			% new conspt: output compare Timer etiher the advanceds from the F4 for TrigB and C with separate ISRs to set and clear
						% OR three GP-Triggers with dedicated output lines, that are set/reset by Timer itself (PSC, ARR and pulse)
						% $\rightarrow$ see schematic wich Trigger has wich line and Graph against according Timers!
		\subsubsection{Debug-Unit}
		A debug-unit, offering eight digital outputs via set.. and rst.. - functions, was established. Fig. ~\ref{dbgUnitLogic} shows a 'ladder' setting and resetting all debug-Pins upon initialization of the module.
		
			\bildGr{b!}{dbgUnitLogic.png}{dbgUnitLogic}{dbgUnitLogic}{0.5\textwidth}

		
		
		\section{Hardware}
			\subsection{STM32F4}
			\begin{figure}[ht]
				\centering
				\includegraphics[height=105mm]{src/_Octane_HW-Structure.pdf}
				\caption{HardWare}
				\label{_Octane_HW-Structure.pdf}
			\end{figure}
			
			\subsection{Wandler, Level-Shifter, HighSider}
			\subsection{Connection of Galvos and Triggers}
				\begin{table}[h!]
					 \begin{tabular}{|p{5.5cm}|p{6cm}|} \hline
					Source1	- Galvo y (slow)& Trigger B\\ \hline
					Source2	- Galvo x (fast)& Trigger A\\ \hline
					 \end{tabular}
					 \caption{Assignment of Triggers and according analogue outputs}
				\end{table}

		\section{\GREY{Software tools}}
			\subsection{\GREY{CubeIDE}}
			\subsection{\GREY{Gcov}}
			\subsection{\GREY{python tools, OpenOCD}}
			% \subsection{\GREY{Valgrind}}
			% \subsection{\GREY{Wavedrom}}
			% \subsection{\GREY{WireShark/USBPcap}}
			% \subsection{\GREY{Gitlab Runner}}
			% \subsection{\GREY{HIL-Setup}}
	
	\chapter{Results}
	\label{cha:Results}
		% Results
	\section{Measurements}
		Messaufbau, werte, ergebnisse, interpretation
		\subsection{Oszi, Debug-Unit und Opto-Detektoren}
		\section{Test-Res}
		\section{Test-Cases}
		\section{Code Coverage}
		\section{Code Review}
		\section{Coverages}
		\section{Review Remarks}
		\section{Gavlo-Performance}
		\section{Project-status}
		\section{ ... }
	% thethesis.tex
	\chapter{Conclusion}
	\label{cha:Conclusion}


% \include{chapters/figures}
% \include{chapters/mathematics}
% \include{chapters/literature}
% \include{chapters/galvoChar}
% \include{chapters/closing}

%%%-----------------------------------------------------------------------------
\appendix                                                             % Appendix 
%%%-----------------------------------------------------------------------------

% \include{back/appendix_a} % Technical supplements
\include{back/appendix_b} % Contents of the CD-ROM/DVD
% \include{back/appendix_c} % Chronological list of changes
% \include{back/appendix_d} % Source text of this document

%%%-----------------------------------------------------------------------------
\backmatter                           % Back part (bibliography, glossary, etc.)
%%%-----------------------------------------------------------------------------

\include{back/_abbrev}

\MakeBibliography % References

%%%-----------------------------------------------------------------------------
% Special page for checking print size
%%%-----------------------------------------------------------------------------

% \include{back/printbox}

%%%-----------------------------------------------------------------------------
\end{document}
%%%-----------------------------------------------------------------------------
