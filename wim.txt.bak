https://dev.to/younup/cmake-on-stm32-the-beginning-3766
https://www.testbytes.net/blog/test-harness/
https://de.wikipedia.org/wiki/Test-Harnisch
https://ieeexplore.ieee.org/abstract/document/393507
https://de.wikipedia.org/wiki/Nicht-blockierende_Synchronisation
https://www.elektroniknet.de/embedded/entwicklungstools/cmsis-vereinheitlich-peripherie-programmierung.29620.html
https://datarespons.com/pros-cons-using-stm32cubemx-code-generation-tool-insead-manually-writing-drivers-arm-cortex-m-microcontroller/
https://de.wikipedia.org/wiki/Test-Harnisch

	https://electronics.stackexchange.com/questions/516131/stm32f4-discovery-adc-trigger-using-timer-2-and-dma-cmsis-core
	https://electronics.stackexchange.com/questions/350088/stm32f407-lan8720a-lwip-freertos-no-received-ethernet-frames
* PC Lint
  Valgrind on embedded


*	FW fürs Octane
*	testcases innheralb eines Tesmodus, bleiben so Teil vom eigetl Code: laut Dietmar nicht nötig, siehe unten
*	testHooks?
	
	
	
* Beratung mit Dietmar Millinger, 02.12.2021, bezügl Unit-testing eines FW-Pojektes ohne OS
	3 Teil-Tests: OS (), IO-Modul, upstream-Kommunikation
		!!! race-conditions bei der Übertragung ISR->main (Übergang von asynchron auf synchron)
			Mit Modultest, der die Funktion ordentlich stresst

		Algorthomen per Modultests abtesten: bekannte inputs/outputs
		
		USB-Testen: zB 100 mal Befehl senden und schauen, ob er ankommt

		Modultests nicht in den production-code reincompilieren, sondern in einr KOPIE des production-codes einfügen, trifft NIE aufm Master-branch auf
		
		im engültigen Code nur etwas Diagnose & Kalibrierung
	
* StaudeckerBesprechnung, 07.12.2021
	Hybridisch verkoppeln von
		experomenteller Messung
		-> Winkel ist der Flache Ausgang
		
		flache Vorsteuerung Ausrechnen: inverse der Übertragungsfunkt auf urspüngliche Signal draufklatschne, Skriopt Relgelung2 Satz 8.1	
		
	Analytsich
		Annahme eines starren Körpers:
		RRTK-Skript	(2.12) ...sys 2ter Ordnung
		

	Eventuell Strom messen um zittern zu ermessen

* Charakterisierung der Galvo-Trägheiten und Massnahmen zum gegenwirken
* REQ: intern extern, nach Modulen sortiert, mit Bildern fürd Rampen-Signale und ab ind D-Arbeit
	mit tags a la
		URxx	User Requirement - Generelle Benutzer-/Systemanforderung
		NRxx	Non-Requirements 
			NRxx ... the Device does no know of absolut time in terms of actual date, hour or minute
			
		RGxx	Requirement GPIO - Anforderung für den Master
		RUxx	Requirement USB - Anforderung für die Slaves
			RU01    | <rs01_acc>  | usbSlave.c    |
				Device must accept commands via USB in SCPI-format (specified in Chap ..), ASCII-Strings, terminated with '\n' dec(), hex() and up to 100bytes of length (excluding the terminator)
			RU02    | <rs02_rep> | usbSlave.c    |
				Device must answer queries, all cmds with a '?' dec() hex() as last data sign, with a meanigfull*) reply message within xx ms, unless Device is in realtime mode*)
			RU03	zu beginn jeder Action eine Nachricht,  within xx ms, bei langen Actions am Ende auch eine acc a la 'vektor geschrieben', 'C-scanned'
		TODI_xx	To Discuss, Punkte die mit Kunden/Entwicklerteam zu besprechen sind
		
		Coverage-REQ

* Kalibration der Analog-Ausgänge: händisch auf 0V, +10V und -10V, per FW auf digit/Volt
* gcov und CLANG auf den Code loslassen
* Flaschehälse/Engpässe in der FW ermitteln
* Schedule Zeichnen, auch wenn pathologisch, nur zum zeigen, daß man bedacht hat
* i-state, h-state definieren
* Comm	(siehe Tilen MAJERLE)
	* USB->main via NBW (non blocking write nach Millinger/Kopetz)
	* Ethernet-Anbindung
	* incl Last-Hypothese, also max. Msg-rate SCPIs/sec
	* incl Fehler-Hypothese?
	* USBpcap oder Kabelhai
* Debug Unit via ein paar gpio pins für timing
* SelfDiagnose: State, FailState(fault-error-failure), VL timing-Pins dort einbauen
* Debug/Test-Setup: local -> gitlab <-> Pi > DUT -> Relaisboard -> Pi
					Relaisboard -> osci (4CH und 16DIs)
					osci -> Pi
* !!! uC - eigener Mode fuer unit-Testing !!!

* Dokumente: Req, Dev-Spec, Test-Spec (Cases), Konzept-Papier (FSM, Trigger-Struktur, protocol, precision/accuracy), HW-Req/Spec, Anf-Doc das zum OCT eh schon existiert, Testprotokolle, Coveragen und call-graphs oder dependency graphs ausm CLANG und gCov heraus
*	gcov!
		
*	controll flow graph
			clang++ -emit-llvm -S prog.cpp -o prog.ll
			opt --dot-cfg prog.ll
			
			
*	callgraph
			$ clang++ -S -emit-llvm main1.cpp -o - | opt -analyze -dot-callgraph
			$ dot -Tpng -ocallgraph.png callgraph.dot
	
ODER: Anbindung eines FPGAs um schneller Signale zu erzeugen, RAM per AXI oder Wishbone lesen

	Christian fragen!
	

Charakterisierung der Galvos und Massnahmen zum gegenwirken

ODER: Anbindung eines FPGAs um schneller Signale zu erzeugen

	Christian fragen!

	
	FW
		Error Handlicng / structured exception handling, Fehlerspeicher
		
		Aufgaben/Taks darstellen als Transactions nach Millinger
		
		USB-comm via RingBuffer mit non-blocking write
		
		Prio0: DAC-write
		Prio1: USB-interr
		Prio2: main-loop


CI/CD:
	gitlab triggert einen runner

	entweder:
		VM oder buildserver mit Debian, dort einen GitlabRunner mit CrossC
		oder Docker mitn Crosscompiler
		
	und Raspberry+HW auch ein Gitlab runner

	https://docs.gitlab.com/ee/topics/build_your_application.html
	https://docs.gitlab.com/runner/install/index.html
	https://medium.com/devops-with-valentine/use-your-raspberry-pi-to-run-gitlab-ci-jobs-8cc29fa49dbe
	https://github.com/features/packages
	https://docs.gitlab.com/ee/ci/docker/

https://github.com/ThrowTheSwitch/CMock/blob/master/docs/CMock_Summary.md		
		
DOC
	% keine rethorischen Fragen!
	% Galvos ... colloquial!
	% II. Motivation -> C. Motivation als Teil der Einleitung
	% Verzehnfachung der Frequenz .. kann entfallen, das kennt man
	% s = jw, Betragsbildung fehlt
	% Danksagung ohne akad. Titel, kein blabla, sondern ein Fliess-Satz
	% Refernzeirungen: Section, Table, Figure immer mit großbuchstben beginnen
	% Im Bodediagramm Abb.6 hast du den Amplitudengang auch logarithmisch gezeichnet. Das ist nicht üblich.
	% Der Phasengang eines Systems 2.O geht auf -180°. Bei dir auf +180°. Kann das stimmen?
	% In deiner „Konklusion“, ich würde nicht sagen, dass das Steuersignal mit der inversen multipliziert wird. Sondern man berechnet das Steuersignal so, dass der Ausgang einer Sollkurve folgt. Nachdem das alles mit Sollgrößen passiert hat man auch kein Problem mit Rauschen. Auch die physikalischen Grenzen bei der Stellgröße hat man somit selbst in der Hand.


CI/CD:
	gitlab triggert einen runner

	entweder:
		VM oder buildserver mit Debian, dort einen GitlabRunner mit CrossC
		oder Docker mitn Crosscompiler
		
	und Raspberry+HW auch ein Gitlab runner

	https://docs.gitlab.com/ee/topics/build_your_application.html
	https://docs.gitlab.com/runner/install/index.html
	https://medium.com/devops-with-valentine/use-your-raspberry-pi-to-run-gitlab-ci-jobs-8cc29fa49dbe
	https://github.com/features/packages
	https://docs.gitlab.com/ee/ci/docker/

https://github.com/ThrowTheSwitch/CMock/blob/master/docs/CMock_Summary.md

https://www.testbytes.net/blog/test-harness/
https://de.wikipedia.org/wiki/Test-Harnisch


DRS	
	https://docs.google.com/document/d/1qCRBlmqj5Z9V7Yu9tlRmKCh2869QmjOHM97UmYg1R90/edit#
	https://trello.com/b/gDhlDnnC/stroboskop
		Validierung mit WireShark, Oszi und Opto-Detektor

TCs	
	Unit
	Integ
	Load
	Fault
	end2end

RTOS
	https://docs.zephyrproject.org/latest/boards/index.html#boards
	https://micro.ros.org/docs/concepts/rtos/comparison/
	https://docs.zephyrproject.org/latest/reference/kernel/other/atomic.html

CI/CD
	https://stackoverflow.com/questions/47281209/what-is-gitlab-runner
	https://www.atlassian.com/de/continuous-delivery/continuous-integration/git-hooks
	https://opensource.com/life/16/8/how-construct-your-own-git-server-part-6
	https://www.stupid-projects.com/devops-for-embedded-part-3/
	https://www.stupid-projects.com/devops-for-embedded-part-1/
	https://www.stupid-projects.com/devops-for-embedded-part-2/
	https://community.st.com/s/question/0D50X0000BbN8Gk/how-do-i-build-stm32cubeide-projects-using-the-command-line-and-a-continuous-integration-engine
	https://community.st.com/s/question/0D53W00000aIJFQ/build-server-vendors-cicd-for-stm32
	https://github.com/lpodkalicki/stm32-toolchain-docker
	https://www.vipinajayakumar.com/continuous-integration-of-latex-projects-with-gitlab-pages.html
	https://tex.stackexchange.com/questions/459484/compiling-latex-files-automatically-with-gitlab-ci

coverage/clang-tree




https://rawats.medium.com/using-raspberry-pi-for-embedded-systems-development-part-1-2d32c42acb5c
https://blog.podkalicki.com/how-to-compile-and-burn-the-code-to-stm32-chip-on-linux-ubuntu/

openOCD 
		https://firmlyembedded.co.za/programming-an-stm32-with-a-st-link-and-raspberry-pi/
		https://learn.adafruit.com/programming-microcontrollers-using-openocd-on-raspberry-pi/compiling-openocd
		https://learn.adafruit.com/programming-microcontrollers-using-openocd-on-raspberry-pi
		https://www.mikrocontroller.net/topic/502996#6398475
	sudo apt-get update
	sudo apt-get install git autoconf libtool make pkg-config libusb-1.0-0 libusb-1.0-0-dev
	git clone http://openocd.zylin.com/openocd
	cd openocd
	./bootstrap
	./configure --enable-sysfsgpio --enable-bcm2835gpio
	make
	sudo make install

VL hilft das: sudo apt-get install binutils-arm-none-eabi
oder das:	https://www.raspberry-pi-geek.com/Archive/2017/22/STM32-Development-with-CubeMX-and-Eclipse
